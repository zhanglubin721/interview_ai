- **RocketMQ 没有像 Kafka 那样“开启就生效”的**幂等生产（enable.idempotence）或**端到端 EOS**。
- **RocketMQ 的交付语义是 at-least-once**：可能重复投递；官方不提供“消费恰好一次”。
- 要做到“**DB 不重、不漏**”，需要你在**消费端做幂等 + 正确的 ack/重试控制**；在**生产端要么用事务消息**（只保证“本地事务成功 ↔ 消息可见”），要么用 **Outbox+CDC** 等模式。





## **1) 生产端：没有“幂等开关”，能用的能力**

- **普通发送（SYNC/ASYNC/ONEWAY）**：重试会导致**可能重复**。
- **事务消息（两阶段）**：只保证**本地事务成功时消息最终可见**；**不会**让消费者“恰好一次”，消费端仍可能重复。
- 建议：把**业务幂等键**放进 keys 或 user properties，比如 orderId/txId，供下游去重。





## **2) 消费端：幂等 + ack/重试**

### **A. Push 模式（**DefaultMQPushConsumer**）**

- **没有“手动 ack”API**；你通过**返回值**告诉 Broker：
  - 成功：CONSUME_SUCCESS → Broker 前移该组在该队列的 offset；
  - 失败：RECONSUME_LATER → Broker 按重试策略**稍后重投**（到达上限进 DLQ）。
- 因为可能重复，**必须幂等**。典型写法（伪码）：

```java
consumer.registerMessageListener((MessageListenerConcurrently) (msgs, ctx) -> {
  for (MessageExt m : msgs) {
    String bizKey = m.getUserProperty("bizKey"); // 或 m.getKeys()
    try {
      if (dedup.tryInsert(bizKey)) {      // Redis SETNX / DB 唯一键
        // 在 @Transactional 里做 UPSERT 等业务写
        applyBusiness(m);
      }
    } catch (Exception e) {
      return ConsumeConcurrentlyStatus.RECONSUME_LATER; // 触发重投
    }
  }
  return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
});
```



### **B. POP 模式（5.x，显式 ACK）**

- Broker 给出一批“**暂时不可见**”的消息（invisible time）。
- **你处理成功后必须显式** **ack**；如果**不 ack 或处理失败**，不可见期过后会**重新投递**。
- 写法要点：**DB 事务成功后再 ack**，失败就不 ack：

```
PopResult r = consumer.popMessage("T", "*", 16, 10000);
for (MessageExt m : r.getMsgFoundList()) {
  try {
    tx.begin();
    if (dedup.tryInsert(bizKey(m))) {
      applyBusiness(m);
    }
    tx.commit();
    consumer.ack(m);        // 只在成功后 ack
  } catch (Exception e) {
    tx.rollback();          // 不 ack，等重投
  }
}
```

> 广播消费（Broadcasting）下**无重试/DLQ**，失败不会重投，更要靠**本地补偿/幂等**。



## **3) 幂等落地清单（通用于 Push/POP）**

- **幂等键**：orderId/txId/traceId 等，放到 keys 或 user properties；**不要依赖** **msgId**（重发会变）。
- **去重存储**（二选一或叠加）：
  1. **DB 唯一约束**：processed_event(idempotent_key UNIQUE)，失败转为 UPSERT/忽略；
  2. **Redis SETNX** + 过期：降低 DB 冲突，最终以 DB 唯一键兜底。
- **DB 写法**：尽量 **UPSERT**（INSERT ... ON DUPLICATE KEY UPDATE），使“重放=幂等空操作”。
- **提交时机**：**DB 事务成功 →（Push）返回成功 /（POP）显式 ack**；失败回滚并让消息重投。
- **DLQ 处理**：为集群消费配置 maxReconsumeTimes，订阅并监控 <topic>%DLQ%<group> 做人工/批量补偿。



## **4) 和 Kafka 的差异一句话概括**

- **Kafka**：有**幂等生产**与**事务**（在 Kafka 内部管道可做到 EOS）；
- **RocketMQ**：**没有内建幂等生产或消费恰好一次**；提供**事务消息（仅发布侧一致性）**、**重试/DLQ/POP ack**。
- 因此 RocketMQ 的“恰好一次”只能在**业务边界**上通过**幂等设计**实现。



### **推荐默认姿势（生产）**

- 发送：**同步发送**（关键链路可用事务消息保障“写库→发消息”的一致性）。
- 消费（集群）：**并发消费 + 业务幂等 + 失败重投 + DLQ**；
- 消费（POP）：**DB 成功后再** **ack**；
- 不要依赖 msgId 去重；**永远带业务幂等键**并在 DB 侧设唯一约束/UPSERT。