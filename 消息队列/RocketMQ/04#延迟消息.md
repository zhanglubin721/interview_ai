## **1) 能力一览**

- **用途**：下单未支付超时关单、T+N 后执行、重试回退、定时通知等。
- **消费侧无感**：消费者照常订阅**真实 Topic**；只是在**到期**前不会收到消息。
- **语义**：**不早于**设定时间投递（可能稍晚，取决于负载/调度粒度）。交付仍是 **at-least-once**。





## **2) 两代机制的核心差异**

### **RocketMQ 4.x：**固定“延迟等级”

- **只能选等级，不支持任意时间点**。默认 18 级（示例：1s 5s 10s 30s 1m 2m ... 1h 2h），可在 broker.conf 用 messageDelayLevel 自定义。
- **实现**：Broker 把带延迟的消息暂存在内部主题 SCHEDULE_TOPIC_XXXX 的某个队列（按等级划分），到点后再转发回**真实 Topic/Queue**。
- **特点**：配置简单，延迟精度=等级粒度；大规模/多级混用时，调度线程扫描压力需要注意。



### **RocketMQ 5.x定时（Timer）消息**

- **支持**“在某个时间点（毫秒级）投递”，用 deliverTimeMs/seconds 指定。
- **实现**：独立的定时存储与**分层时间轮**（TimerWheel）等机制，按桶推进，规模化更好，精度更细（实际误差仍受负载/参数影响）。
- **兼容**：仍可使用 4.x 的“等级延迟”，但更推荐直接用“定时投递”。





## **3) 代码怎么写**

### **4.x：按“延迟等级”发送**

```java
DefaultMQProducer p = new DefaultMQProducer("pg");
p.start();

Message msg = new Message("order-close", "tagA", body);
// 选一个延迟等级（从 1 开始计数）
msg.setDelayTimeLevel(16); // 举例：10分钟/20分钟之类，取决于 broker 配置
SendResult r = p.send(msg);

p.shutdown();
```



### **5.x：按“绝对时间”发送**

```java
DefaultMQProducer p = new DefaultMQProducer("pg");
p.start();

Message msg = new Message("order-close", body);
// 在指定时间（毫秒时间戳）投递
msg.setDeliverTimeMs(System.currentTimeMillis() + 15 * 60 * 1000L);
SendResult r = p.send(msg);

p.shutdown();
```

> 消费端**无需变化**：正常 subscribe("order-close", "*") 即可；消息会在“到点”后到达。





## **4) Broker 里到底做了什么**

### **4.x（延迟等级）**

1. Producer 发送时带上 delayTimeLevel；Broker **先写入 CommitLog**，并把消息的 Topic 暂时改为 SCHEDULE_TOPIC_XXXX、队列=对应等级。
2. 后台“调度派发”线程按等级队列扫描：
   - 到期就**重投**到消息原始的 realTopic/realQueueId，重新写入 CommitLog（相当于转发一次）。
3. 消费者最终从**真实 Topic**拉到消息。

### **5.x（定时）**

- 消息写入**定时存储**并挂到时间轮桶里；到期后“出桶”，再转投到真实 Topic。
- 设计上把调度和普通写入解耦，更利于高并发与大批量定时任务。





## **5) 常见限制 & 坑位**

- **时间精度与延迟**：到期时间是**下限**；实际投递可能因负载、刷盘/调度粒度而略晚（尤其 4.x）。
- **顺序性**：延迟会打破原有投递时序；**不能指望与非延迟消息/不同延迟的消息保持严格顺序**。需要顺序的业务要单独设计（如同键单队列 + 同等级）。
- **事务消息**：通常不与延迟混用（即使发送 API 允许，语义复杂且不推荐）。
- **等级表（4.x）变更**：修改 messageDelayLevel 需谨慎，**集群一致**；变更会影响后续入队的等级含义，历史已入队的不受影响。
- **大批量定时**：4.x 大量等级+海量待触发时可能造成调度扫描压力；5.x 的 Timer 更适合批量定时。
- **时钟同步**：Broker 与客户端时钟偏差过大，可能导致“早/晚”感知不一致；保持 NTP 同步。
- **消息大小**：延迟消息依然受普通消息大小限制；过大影响写入与触发效率。
- **监控**：关注“定时池积压量、到期触发延迟、转投失败/重试次数”。





## **6) 典型用法建议**

- **订单超时关闭/支付超时**：5.x 用 deliverTimeMs = now + 15min 最直观；4.x 选接近的延迟等级（比如 15 分钟对应的级别）。
- **重试回退**：第一次失败写 10s 后再试；再失败 1m、5m…（4.x 用逐级延迟；5.x 用绝对时间或按策略计算下次时间）。
- **到期提醒/定点任务**：5.x 精准定时更合适；如果是“真·调度”，也可考虑专业调度系统配合。





## **7) 生产默认姿势（给你一条“口令”）**

- **用 5.x**：优先选择**定时消息（deliverTimeMs）**，更灵活更可观测。
- **仍在 4.x**：用 **延迟等级**，把 messageDelayLevel 统一配置在所有 Broker；挑最近的等级，不要在业务里做小数/奇怪间隔。
- **可靠性**：延迟只决定“何时可见”，**消费仍可能重复**，务必保持**幂等**。
- **监控与回压**：盯“到期消息触发延迟”和“待触发条目数”，必要时扩容或调粒度参数。



### **一句话总结**

- **4.x**：固定等级的“延迟投递”；简单、粗粒度。
- **5.x**：支持“定时（绝对时间）投递”；更灵活、扩展性更好。
- 消费侧无感，但**到期不早于**设定时间；顺序不保证，仍需幂等。生产上优先 5.x 定时，4.x 用等级并统一配置。