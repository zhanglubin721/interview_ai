## **RocketMQ 的“半消息”（事务消息）怎么工作**

**目标**：把“本地事务（如写库）成功 ↔ 消息对消费者可见”绑定在一起。

**流程（两阶段）**

1. **PREPARE：发送半消息**

   Producer 调 sendMessageInTransaction(...)，Broker 先把消息写入一个内部的“半消息存储”（不可被消费），立刻给 Producer 返回（半消息成功）。

2. **执行本地事务**

   Producer 在 TransactionListener#executeLocalTransaction 里做数据库等本地操作。

3. **COMMIT / ROLLBACK**

   - 本地事务成功 → commit：Broker 将该半消息“转正”（再写回真实 Topic/Queue），此时**消费者才看得见**。
   - 本地事务失败 → rollback：半消息被丢弃，**对消费者始终不可见**。

4. **事务回查**（兜底）

   如果 Producer 在第 3 步前挂了 / 网络抖动，Broker 会定期对“长期未决”的半消息发起**回查**，回调 checkLocalTransaction 让 Producer 决定 commit 或 rollback，避免卡死。

> 直白地说：**半消息 = 先把消息“暂存但不投递”，等你说 OK 我再放出来**；你没回话，Broker 会追着你问。



**典型代码骨架**

```java
TransactionMQProducer p = new TransactionMQProducer("pg-tx");
p.setTransactionListener(new TransactionListener() {
  @Override
  public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
    try {
      // 做本地事务（写库等）
      return LocalTransactionState.COMMIT_MESSAGE;
    } catch (Exception e) {
      return LocalTransactionState.ROLLBACK_MESSAGE;
    }
  }
  @Override
  public LocalTransactionState checkLocalTransaction(MessageExt msg) {
    // 回查：查业务状态，返回 COMMIT 或 ROLLBACK
    return LocalTransactionState.COMMIT_MESSAGE;
  }
});
p.start();
p.sendMessageInTransaction(new Message("T", body), null);
```

**注意点**

- 事务消息只保证“**可见性与本地事务一致**”，**不等于消费侧恰好一次**；消费者仍需幂等。
- 与延迟/批量等特性组合有限制（视版本）。
- 要监控“半消息积压/回查次数”。





## **Kafka 的“事务”跟它有什么不同？**

- Kafka **没有“半消息队列”**。事务生产者把消息正常写入分区，但 Broker 维护**事务状态与标记**：
  - 在 **commit** **之前**，对 read_committed 模式的消费者，**未提交的消息不可见**（通过 LSO/控制批次实现）。
  - abort 则使这批消息对 read_committed 永远不可见。
- Kafka 的事务常配合 **幂等生产** 与 sendOffsetsToTransaction，实现“**读 → 处理 → 写回**”的端到端 **EOS**。



**一句话对比**

- **RocketMQ**：显式“半消息 → 转正/回滚 + 回查”。
- **Kafka**：写入即落日志，用**事务提交/中止标记 + 隔离级别**控制消费者可见性，**没有“半消息”这个名词/机制**。