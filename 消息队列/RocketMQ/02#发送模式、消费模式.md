# **1) 生产者发消息有几种“模式”**

## **A. 交互模式（最核心的三种）**

**同步发送（SYNC）**

SendResult sr = producer.send(msg);

- 阻塞等待 Broker 返回结果（OK/重试/异常）。
- **可靠性最高**（可拿到 sendStatus/queue/offset），链路清晰，方便告警与补偿。
- **生产上最常用**；关键业务默认用它。



**异步发送（ASYNC）**

```
producer.send(msg, new SendCallback() {
  public void onSuccess(SendResult r) {}
  public void onException(Throwable e) {}
});
```

- 不阻塞业务线程，回调里处理成功/失败。
- 适合**高吞吐、低延迟**链路；注意**失败补偿**（重试/降级/落本地堆积）。



**单向发送（ONEWAY）**

producer.sendOneway(msg);

- **不等待响应**，最省时；**可能丢**（不可知失败）。
- 只用于**日志/埋点**等不敏感场景，**关键业务禁用**。



## **B. 语义/功能层（在上面三种“交互模式”之上选择）**

- **顺序消息**：给消息设置分片键（sharding key）/MessageQueueSelector，把同键路由到同队列；消费者用 **顺序消费** 才有效。
- **延时/定时消息**：指定 delayTimeLevel（4.x 18 个等级）或 5.x 的 deliverTimeMs/second 精准延迟。
- **事务消息**（两阶段）：TransactionMQProducer + TransactionListener。先发半消息（prepare）→ 执行本地事务 → commit/rollback；Broker 可回查。**用于“本地事务成功 ↔ 消息可见”一致性**。
- **批量消息**：send(Collection<Message>) 同批同 topic 同属性，提升吞吐（每条 ≤ 1MB，总体 ≤ 4MB 左右，视版本/配置）。

> 生产结论：**同步发送**是大多数业务的默认；**异步**用在实时高吞吐；**事务消息**用在“写库与发消息一致”场景；**单向**只给日志。





# **2) 消费者“消费模式”有几种**

## **A.** **消费模型（投递给同组谁？）**

**集群消费（Clustering）**（默认）

- 同一消费组内**分摊**队列，一条消息**只给一个实例**。
- 支持失败重试与 **DLQ**（死信）。
- **生产最常用**。



**广播消费（Broadcasting）**

- 同组**每个实例**都收到**每条**消息。
- **不支持 Broker 端重试/DLQ**（失败不重投）；适合**配置下发/缓存失效**这类“人人一份”的场景，**不适合业务数据**。

> 切换方式（Push Consumer）：consumer.setMessageModel(MessageModel.CLUSTERING/BROADCASTING);



## **B.** **并发模型（在单个队列上如何消费）**

**并发消费**：MessageListenerConcurrently

- 吞吐高；**可能打乱队列内顺序**（失败会重投，多个线程处理）。
- **生产默认**。



**顺序消费**：MessageListenerOrderly

- 对每个队列加锁，单线程拉取；**保证队列内有序**。
- 失败会阻塞该队列（吞吐下降）。用于“同订单/同键严格时序”。



## **C.** **拉取形态**

- **Push（推荐）**：DefaultMQPushConsumer，本质长轮询；最常用。
- **Pull/LitePull**：需要自己控制 offset/再均衡，**高级用法**。
- **POP 模型（5.x）**：Broker 端“临时隐藏 + ack”机制，像 SQS；新项目有采纳，但存量仍以 Push 为主。



## **D.** **过滤模式**

- **TAG 过滤**（服务端哈希粗过滤 + 客户端精过滤）。
- **SQL92 过滤**（更灵活，开销略高）。







# **3) 生产上的“常见组合”（给你一个速选表）**

| **需求**           | **生产者**                 | **消费者**              | **备注**                                         |
| ------------------ | -------------------------- | ----------------------- | ------------------------------------------------ |
| 大多数业务数据处理 | **同步发送**               | **集群 + 并发**         | 最稳妥的默认组合                                 |
| 高吞吐/低延迟      | **异步发送**               | 集群 + 并发             | 做好失败回调重试/降级                            |
| 严格按键顺序       | 同键路由同队列（Selector） | **集群 + 顺序**         | 失败会阻塞该队列，评估吞吐                       |
| 配置/缓存广播      | 同步/异步均可              | **广播 + 并发**         | 消费端**自幂等**，无重试/DLQ                     |
| 本地事务一致性     | **事务消息**               | 集群（并发/顺序视业务） | 只保证“消息可见性与本地事务一致”，消费端仍需幂等 |
| 业务定时/超时回查  | 同步/异步 + **延时/定时**  | 集群 + 并发             | 4.x 等级延时；5.x 支持精确时间                   |





# **4) 关键代码骨架**

**生产者（同步/异步/单向）**

```
DefaultMQProducer p = new DefaultMQProducer("pg");
p.start();
SendResult r1 = p.send(new Message("T", "tag", "k1", body));            // SYNC
p.send(new Message("T", body), new SendCallback(){...});                // ASYNC
p.sendOneway(new Message("T", body));                                   // ONEWAY
p.shutdown();
```

**事务消息**

```
TransactionMQProducer tp = new TransactionMQProducer("pg-tx");
tp.setTransactionListener(new TransactionListener() {
  public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
    // 本地事务：成功 COMMIT_MESSAGE；失败 ROLLBACK；不确定 UNKNOW
  }
  public LocalTransactionState checkLocalTransaction(MessageExt msg) { ... } // 回查
});
tp.start();
tp.sendMessageInTransaction(new Message("T", body), null);
```

**消费者（集群 + 并发）**

```
DefaultMQPushConsumer c = new DefaultMQPushConsumer("cg");
c.setNamesrvAddr("ns:9876");
c.setMessageModel(MessageModel.CLUSTERING); // or BROADCASTING
c.subscribe("T", "tagA || tagB");           // 或 SQL92 表达式
c.registerMessageListener((MessageListenerConcurrently) (msgs, ctx) -> {
  for (MessageExt m : msgs) {
    // 业务处理，失败 return RECONSUME_LATER （会重投并最终进 DLQ）
  }
  return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
});
c.start();
```

**消费者（顺序）**

```
c.registerMessageListener((MessageListenerOrderly) (msgs, ctx) -> {
  try { /* 业务处理 */ return ConsumeOrderlyStatus.SUCCESS; }
  catch (Exception e) { return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; }
});
```





## **总结**

- **生产者三种交互模式**：同步、异步、单向；**同步最常用**，异步用于高吞吐，单向用于日志。功能层还有顺序、延时/定时、事务、批量。
- **消费者的两大模型**：**集群**（最常用）与**广播**；并发 vs 顺序两种监听器；推（主流）/拉（进阶）/POP（5.x 新模型）。
- 生产默认推荐：**同步发送 + 集群并发消费**；对有序/一致性/广播等特殊需求再选对应模式，并始终做好**幂等/重试/DLQ**与监控。