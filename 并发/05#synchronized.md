# **1) 语义：它保证了什么？**

- **互斥**：同一把“监视器锁（monitor）”同一时刻只被一个线程持有。
- **可重入**：同一线程可以重复进入同一监视器，内部维护重入计数。
- **内存语义（JMM）**：
  - 进入（monitorenter）具备 **acquire**：之后的读写不能被重排到它之前；并能看到之前持有者在退出前的写。
  - 退出（monitorexit）具备 **release**：之前的写在退出后对后续获得该监视器的线程可见。
  - 规则：**对同一监视器的解锁 happens-before 后续的加锁**。

> 这就解释了为什么 synchronized 同时解决“互斥 + 可见性/有序性”。





# **2) 字节码与异常保障**

- **块级**：synchronized(obj) { ... } 编译为一对 monitorenter / monitorexit。
- **方法级**：synchronized 方法在字节码上带 ACC_SYNCHRONIZED 标志，JVM 进入/退出方法时隐式执行 monitorenter/monitorexit。
- **异常泄露保护**：编译器会生成 **两处** monitorexit（正常路径 + catchall），确保块内异常也会释放监视器，不会“锁泄露”。







# **3) 锁放在哪：对象头 & 监视器**

- **对象头（Mark Word）**：保存运行时状态（哈希、年龄、锁标志、指向栈上锁记录/监视器等）。

- **监视器（ObjectMonitor）**：HotSpot 的重量级锁结构，包含：

  - owner（当前持有线程）、recursions（重入计数）
  - EntryList（竞争进入但未持有者）、WaitSet（wait() 后等待 notify 的）
  - 互斥/条件队列元数据等

- **一把锁的物理形态可能不同**：**无锁 → 轻量（栈上“薄锁”）→ 膨胀为 ObjectMonitor（重量）**。

  > 历史上还有**偏向锁**：JDK 15 默认禁用，JDK 18 移除。现代 JDK 可直接理解为“无锁→轻量→重量”。







# **4) 获取/释放的快慢路径（热点实现思路）**

## **4.1 轻量级锁（Thin Lock，栈上锁记录）**

场景：**无/低竞争**。

- 进入时，JIT 生成的快路径尝试把对象头的 Mark Word 通过 **CAS** 改写为 **指向本线程栈上“锁记录（Lock Record）”的指针**（并设置相应锁标志位）。
- 成功 ⇒ 获锁（不用 OS 互斥量，也不阻塞）。
- **可重入**：同一线程再次进入时，会在栈上再压一个锁记录（或递增计数），无需再 CAS 对象头。
- 退出时：把对象头的 Mark Word **还原**（从指针还原回无锁形态），并弹出/减少重入计数。





## **4.2 膨胀为重量级（ObjectMonitor）**

触发：CAS 失败且检测到**多线程竞争**、或块内调用 wait()（需要监视器的条件队列语义），或其他导致轻量路径无法满足的情形。

- **膨胀（inflate）**：
  - 为该对象分配/关联一个 ObjectMonitor，把对象头改为“指向监视器”的形态；
  - 之后的进入/退出走 ObjectMonitor::enter/exit。
- **进入**：失败者先做**自旋**（自适应：忙等若干次以等持有者很快释放，避免上下文切换），自旋仍失败则将自己挂到 EntryList，**park** 阻塞等待。
- **退出**：持有者递减重入计数至 0 ⇒ 释放，按策略从 EntryList 唤醒一个/若干等待者（unpark），由它们去竞争。

> 一旦“膨胀”，**不会立刻降级**回薄锁；通常直到这把锁长时间无竞争、对象被 GC 等，才可能回到更轻形态（实现细节依 JVM 版本而异）。







# **5)** **wait/notify**与监视器协作（条件队列）

- **wait() 路径**（要求线程已持有该监视器）：
  1. 把当前线程从“拥有者”身份**释放锁**（重入计数清零），并**加入 WaitSet**；
  2. park 阻塞。
- **notify/notifyAll()**：把 WaitSet 里的一个/全部线程**转移**到 EntryList；**不是**立刻拿到锁。
- 被 notify 的线程随后要**重新参与进入竞争**（EntryList → 获锁），成功后 wait() 才返回。
- 因为 notify 只是“搬运”，被唤醒者**必须用 while 检查条件**（伪唤醒/错唤醒/条件被别人消费）。







# **6) 内存屏障 & 可见性**

- JMM 规定：
  - monitorexit **release**：把临界区内的写刷新为对其他核可见；阻止后续读写重排到退出之前。
  - monitorenter **acquire**：读取到持有者释放后的最新值；阻止之前读写重排到进入之后。
- **实现**：HotSpot 在 JIT IR 中注入 MemBarRelease/Acquire，并映射到各架构最小指令序列（x86 通常借 TSO + 必要屏障，ARM/POWER 用 dmb ish/ldar/stlr 等）。这就是 synchronized 的“可见性 + 有序性”来源。







# **7) 性能策略与 JIT 优化**

- **自适应自旋**：膨胀锁上先短暂自旋，期望持有者很快释放，避免 park/unpark 的内核切换开销。
- **偏向锁（历史）**：无竞争情况下把锁“偏向”某线程，进入/退出几乎零开销（新 JDK 已移除）。
- **锁粗化**：把多个相邻的小 synchronized 合并为一个大临界区，减少加解锁次数。
- **锁消除**：逃逸分析证明对象/锁只在单线程可见 ⇒ **直接去掉 synchronized**（例如局部 StringBuffer 拼接）。
- **栈上分配/标量替换**：进一步配合锁消除，减少分配与同步开销。







## **一图串起来（简化状态流）**

```
        monitorenter
             |
     CAS MarkWord → 成功? ──► [薄锁(栈上锁记录)] ──► monitorexit → 还原MarkWord
             | 否
             v
       [自适应自旋] → 仍失败/有wait()
             v
    [膨胀为 ObjectMonitor(重量)]
             |
     进入：EntryList 阻塞/唤醒竞争
     退出：owner 递减 → 唤醒候选者
```





## **常见问答（面试直击）**

- **为什么是可重入的？** 监视器里记录 owner + recursions；同线程再次进入只累加计数，不会死锁。
- **synchronized 与 ReentrantLock 的关系？** 前者是语言级 + JVM 原语（监视器），后者是 JUC 基于 AQS 的 Java 实现；都提供互斥/可重入与条件队列（wait/notify vs Condition），但后者支持可中断/可超时/可公平等更丰富特性。
- **公平性？** HotSpot 监视器**不承诺严格公平**；调度偏向低切换/高吞吐。要强公平可用 ReentrantLock(true)。
- **为什么能保证可见性？** 解锁的 release 与加锁的 acquire 建立 hb，结合缓存一致性 + 屏障达成。



# 编译与 JIT

```
.java 源码
  │  (1) javac 编译（也可能是注解处理后再编）
  ▼
.class 字节码（bytecode，JVM 的“中间表示”）
  │  (2) JVM 运行时：类加载→验证→链接→初始化
  │  (3) 解释执行（Template Interpreter）先跑起来 + 收集热点信息
  │  (4) 触发 JIT（分层编译）：把“热点方法/热点循环”编成本地机器码
  │       ├─ C1：快速、轻优化，常带性能探针
  │       └─ C2（或 Graal）：深优化，内联/逃逸分析/标量替换/向量化/锁消除…
  │       （OSR：在运行中的长循环中途“换乘”到已编译代码）
  │       （Speculation + deopt：假设不成立时“去优化”退回解释器）
  ▼
本地机器码（放在 Code Cache，中途可重编/去优化）
```



# 栈上锁记录

## **1) 第一次拿这把锁（轻量级快路径）**

- 线程在**自己栈**上压入一条 **Lock Record（锁记录）**，把**对象头 Mark Word 的原值**备份到这条记录里（displacedHeader）。

- 用 **CAS** 把**对象头**从“原 Mark Word”改成“**指向这条 Lock Record 的指针 | 轻量标志**”。

  ⇒ **这一步必须 CAS**，因为这是把“锁的所有权”从“无主”改为“我”。

## **2) 重入（同一线程再次进入同一把锁）**

- **不再改对象头**，只是在**栈上再压一条 Lock Record**，通常把它的 displacedHeader 置 0（表示“重入层”）。

  ⇒ 你说的“栈每重入一次加一层”对；**重入主要靠栈记录来记账**，不是反复改对象头。

## **3) 释放（monitorexit）**

- 逐层**弹栈**：
  - 若顶层 Lock Record 的 displacedHeader == 0：这是重入层，**仅弹栈**即可；
  - 到了**最后一层**时，用 **CAS** 尝试把**对象头**从“指向 Lock Record | 轻量标志”**还原**为 displacedHeader（进入时备份的原头）。
    - **CAS 成功** ⇒ 完全释放，回到**无锁形态**；
    - **CAS 失败** ⇒ 期间可能发生了**膨胀（变重量级）/竞争**，走慢路径（监视器）收尾。

## **4) 之后“再拿一次”**

- 无论是**同一线程过一会儿**再来，还是**别的线程**来，要想重新进入轻量级锁，**又要对对象头做一次 CAS**（把对象头指向新压的 Lock Record）。

  ⇒ 你说的“最后栈里没记录了，下一次再拿要 CAS 对象头”——**没错**。

### **一点补充（别把 Lock Record 只当“重入工具”）**

Lock Record 的作用不止是方便重入：

- **备份原对象头**：让最后一次解锁能**准确还原**对象头（包括可能的 identity hash 信息）。
- **所有权令牌**：对象头指向“**我栈上的** Lock Record”，其他线程一眼就知道“这把锁现在被谁拿着”（指针不在它的栈上）。
- **GC/去优化**：栈上明确记录“我当前持有哪些监视器”，JVM 在 safepoint/去优化时能安全还原现场。
- **平滑升级**：如果中途发生竞争/需要 wait/notify 导致**膨胀为重量级**，解锁时 CAS 还原会失败，凭这条记录的信息**切到监视器慢路径**，保证语义正确。





### **一张 6 步小流程（更直）**

```
首入：
  LockRecord.displaced = Obj.MarkWord
  CAS(Obj.MarkWord, 原值 -> 指向 LockRecord | thin)  // 必须 CAS

重入（同线程）：
  再压 LockRecord(displaced = 0)                      // 不改对象头

退出：
  若 displaced == 0  → 只弹栈
  否则 CAS(Obj.MarkWord, 指向 LockRecord|thin -> displaced) // 释放为无锁
  若 CAS 失败 → 已膨胀 → 走监视器慢路径
```

所以，**你的心智模型是对的**：

- 重入靠“**多条栈上锁记录**”，不重复改对象头；
- **最后一次释放**需要 **CAS 还原对象头**；
- **再次获取**又需要 **CAS 改对象头**。