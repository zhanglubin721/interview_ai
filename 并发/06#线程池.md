# **1) 七个构造参数（语义 + 交互要点）**

```
public ThreadPoolExecutor(
  int corePoolSize,              // ① 核心线程数
  int maximumPoolSize,           // ② 最大线程数（≥ core）
  long keepAliveTime,            // ③ 非核心线程的空闲存活时间（见 allowCoreThreadTimeOut）
  TimeUnit unit,                 // ④ 时间单位
  BlockingQueue<Runnable> workQueue, // ⑤ 任务队列
  ThreadFactory threadFactory,   // ⑥ 线程工厂（命名/优先级/守护线程/异常处理）
  RejectedExecutionHandler handler // ⑦ 拒绝策略
)
```

- **corePoolSize**：线程池的“常驻规模”。少量负载时任务不入队，直接新建 worker ≤ core。

- **maximumPoolSize**：当**队列无法再收纳**且还有压力时，才把线程数从 core 往上扩到 max。

  > **注意**：若 **workQueue 是无界队列（如默认 LinkedBlockingQueue）**，则**永远不会触发**“扩到 maximumPoolSize”，线程数基本固定在 core（除非线程异常退出需要补位）。

- **keepAliveTime + unit**：**非核心线程**空闲多久后回收；若开启 **allowCoreThreadTimeOut**，核心线程也会按此回收（详见 §4）。

- **workQueue**：决定“排队还是扩容”的策略重心（见 §5）。

- **threadFactory**：强烈建议自定义**线程名**（定位问题靠它）、是否 daemon、优先级、UncaughtExceptionHandler。

- **handler**：当**不接受新任务**时的兜底策略（见 §3）。



# **2) 任务提交流程（execute(Runnable) **的“三段式”）

HotSpot 的核心判定是“三步走”，配合状态重检以处理并发竞态：

**Step 1：先尝试直接用新线程执行（不入队）**

- 若 workerCount < corePoolSize，调用 addWorker(cmd, true) → **新建线程**去跑任务，返回。



**Step 2：否则尝试入队**

- 若线程数已达 core，则尝试 workQueue.offer(cmd)。

  - **成功**：进入“排队等待”。为避免竞态，会**二次检查池状态**：
    - 若此时池已不是 RUNNING（比如被 shutdown() 了），则**从队列移除该任务并拒绝**；
    - 若此时没有任何 worker 在跑（例如都挂了），会补一个空任务 worker（addWorker(null, false)）去**消费队列**。
  - **失败**（队列满或 SynchronousQueue 0 容量）：进入 Step 3。

  

**Step 3：扩容到 maximum 或拒绝**

- addWorker(cmd, false) 尝试把线程数扩到 ≤ max；
  - **成功**：新线程直接执行任务；
  - **失败**：触发**拒绝策略** handler.rejectedExecution(...)。

> 同步关键：

- > **RUNNING/SHUTDOWN/STOP/TIDYING/TERMINATED** 等状态与 workerCount 打包在一个 ctl 原子变量里；

- > 提交成功后，worker 的 run() 循环通过 getTask() 从队列取任务；

- > **SynchronousQueue** 下没有“存量任务”，getTask() 走**定时 poll**，配合 keepAliveTime 决定“收缩”。



# **3) 拒绝策略（RejectedExecutionHandler）**

触发时机：**池非 RUNNING**（被关了）**或**（队列已满且线程数已达 max）。内置 4 种：

1. **AbortPolicy**（默认）：抛 RejectedExecutionException。——**强反馈**，最安全。
2. **CallerRunsPolicy**：由**调用者线程**直接执行该任务（若池已关闭则丢弃）。——**自然背压**，限流好用，但要确保调用方能承受执行耗时。
3. **DiscardPolicy**：静默丢弃。——容易“黑洞式丢任务”，除日志/监控非常清楚外不建议。
4. **DiscardOldestPolicy**：丢队列**头部**任务，再重试入队当前任务。
   - **注意**：在 **SynchronousQueue**（0 容量）下相当于**没有可丢的“最老任务”**，通常会直接走拒绝（重试仍失败），效果近似 Abort。

> 实战建议：

- > 面向外部请求的线程池优先 **AbortPolicy** 或 **CallerRunsPolicy**（配合上游超时/重试）；

- > 若要自定义策略，务必**记录日志 + 计数上报**，否则你不知道任务去哪儿了。





# **4)** **allowCoreThreadTimeOut(boolean)** **的语义与影响**

- 默认：**核心线程**即使空闲也**不回收**；**非核心线程**空闲超过 keepAliveTime 被回收。
- allowCoreThreadTimeOut(true)：**核心线程也参与回收**（空闲超过 keepAliveTime）。
  - 典型用途：**低 QPS 夜间**或**突发型**业务，节省线程占用（栈内存+调度负担）。
  - 配置注意：keepAliveTime **必须 > 0** 才有意义。
  - 代价：下一次突发到来时，可能需要重新建线程，**首波延迟上升**。

> 组合经验：

- > **IO 密集/突发**场景 + SynchronousQueue：常搭配 allowCoreThreadTimeOut(true)，让线程池“像气球一样”涨缩。

- > **低延迟要求**的常驻服务：一般**不超时核心线程**，保证随时有 worker 在等活。





# **5) 队列选型：Synchronous / Array / Linked（重点对比）**

## **5.1 SynchronousQueue（零容量“直接移交”）**

- **容量=0**：提交任务时**必须**有空闲 worker 来“接货”；否则**不会入队**。
- 特性：**极强的弹性扩容**——在 Step 2 永远失败（无容积），立即触发 Step 3 往 **maximumPoolSize** 扩；
  - 若线程数已达 max，则触发**拒绝**（或阻塞，取决于你外层如何提交）。
- 适合：**高并发、短任务、突发流量**；希望“优先扩线程不堆任务”。
- 组合典型：Executors.newCachedThreadPool() 就是 core=0, max=Integer.MAX_VALUE, keepAlive=60s, queue=SynchronousQueue。
- 细节：支持 fair 构造（FIFO vs LIFO 匹配），默认**非公平**吞吐更高。
- **坑/风险**：
  - 最大线程数必须谨慎，**否则线程洪泛**；
  - 任务一旦过多且线程达上限 → **立刻拒绝**（不会堆积在队列里）。





## **5.2 ArrayBlockingQueue（定长数组，有“公平”可选）**

- 固定容量，**内存可控**、**局部性好**；offer/poll 基于单锁（ReentrantLock，可选**公平锁**）。
- 适合：需要**明确背压**与**可预估容量**的场景；**吞吐**与**延迟**之间比较均衡。
- 组合效果：
  - core 已满 → **先入队**直到队列满；
  - 队列满后才**扩到 maximum**；
  - 若已到 max 仍有提交 → **拒绝**（触发 handler）。
- 公平 vs 非公平：公平=严格 FIFO，但吞吐会降（更多上下文切换），大多数服务**非公平**即可。
- **坑/风险**：容量估太小会频繁扩线程/拒绝；太大又会**排队延迟变长**。





## **5.3 LinkedBlockingQueue（链表，可**显式**指定容量；默认几乎无界）**

- 链表结构，**put/take 两把锁**（并行度优于 Array），单个任务多一个 Node 对象开销。

- 若**不显式传容量**，默认 Integer.MAX_VALUE，几乎**无界**。

- 适合：任务可能**突然积压**、不希望轻易拒绝；或者**任务执行时间较长**，用排队换扩容。

- 组合效果（关键！）：

  - 队列未满时，线程池**几乎不扩到 maximum**（因为 Step 2 总能成功），线程数基本停在 **core**；
  - 这意味着 **maximumPoolSize 形同虚设**，**吞吐受限于 core**，以及**排队时延**可能增大。

  

- **坑/风险**：

  - 默认无界 → 可能**挤爆内存**或造成长时间滞留；
  - 想利用 maximum 扩容时，请**务必设置一个合理的容量**，否则“扩容路径”永远到不了。

> 小结对比（经验规则）

- > **优先扩线程、不排队**：SynchronousQueue（加大 max + 合理 keepAlive；警惕线程洪泛）

- > **有上限排队 + 适度扩线程**：ArrayBlockingQueue(cap)（容量=系统可接受的滞留量；需要严格 FIFO 可开启公平）

- > **长任务/容忍滞留/不想频繁拒绝**：LinkedBlockingQueue(cap)（**一定要设 cap**；不设=基本不扩到 max）



# **6) 典型配置模板与建议**

### **A. 短任务/突发高并发（追求吞吐、可接受拒绝）**

```
new ThreadPoolExecutor(
  core, max,
  60, TimeUnit.SECONDS,
  new SynchronousQueue<>(),               // 直接移交
  namedFactory("biz-io-%d"),
  new ThreadPoolExecutor.CallerRunsPolicy() // 或 Abort，视上游而定
);
// 可选：executor.allowCoreThreadTimeOut(true);
```



### **B. 有界背压、延迟可控（通用 Web 服务）**

```
new ThreadPoolExecutor(
  core, max,
  30, TimeUnit.SECONDS,
  new ArrayBlockingQueue<>(capacity, false), // 非公平更高吞吐
  namedFactory("web-%d"),
  new ThreadPoolExecutor.AbortPolicy()
);
```



### **C. 长任务/不希望频繁拒绝（但要显式**容量）

```
new ThreadPoolExecutor(
  core, max,
  30, TimeUnit.SECONDS,
  new LinkedBlockingQueue<>(capacity), // 别用无界默认
  namedFactory("long-%d"),
  new ThreadPoolExecutor.DiscardOldestPolicy() // 或 Abort/CallerRuns
);
```

> 线程数估算：

- > **CPU 密集**：core ≈ NCPU（或 NCPU ± 1），max ≈ core；

- > **IO 密集/阻塞较多**：core ≈ NCPU * (1 + (等待时间/计算时间))，max 适度更大。

- > 结合**监控**（队列长度、任务耗时分布、拒绝次数、CPU 使用率）持续校准。





# **7) 常见易错点与调优检查单**

- **最大线程数不起作用？**

  九成因为用的 **无界 LinkedBlockingQueue**，导致永远走“入队”而不是“扩容”。——**给队列设上容量**。

- **延迟尾部变长？**

  队列太大或任务过慢。定位：看队列长度、任务 P99 执行时间，必要时拆分任务/限流/降级。

- **频繁拒绝或线程飙升？**

  SynchronousQueue 配置过激或 max 设太小/太大。结合业务峰值修正 max 与 keepAliveTime。

- **内存涨？**

  Linked 无界队列积压。立刻改为**有界**并配拒绝策略；评估是否需要拆池/隔离慢任务。

- **核心线程停不下来**？

  检查是否开启了 allowCoreThreadTimeOut(true) 且 keepAliveTime > 0。

- **定位问题困难**？

  自定义 ThreadFactory，线程名带上池名与自增编号；记录拒绝计数、队列长度、活跃线程数、任务耗时直方图。

