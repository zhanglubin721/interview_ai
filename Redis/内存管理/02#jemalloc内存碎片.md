# 内存碎片的解决方法大体上分为两种

**1.尽可能减少内存碎片**

**2.想办法重新利用这些内存碎片**





## **1) 小对象（走 slab/run）的碎片重用：**把“快吃完的盘子”先吃完

- **等分 + 位图管理**：同一 size-class 的小对象放进同尺寸的 **slab(run)**，每个 run 用 **bitmap** 标记空/占。
- **选择策略**：分配时优先用当前 run（slabcur）；没有空位再从 **非满集合**里挑**“最满的那块”**（剩余空位最少）继续塞——这样把**空洞集中在尽量少的 run** 上。
- **释放时**：把对应 bit 清 0；**整块 run 如果空了**，就能被归还给 arena 的页池（后面可以 purge 给 OS，或转作其它用途）。
- **效果**：让“内部碎片”**聚集**而不是“撒满地”，腾出“整块可回收”的 run。

> 小对象的空洞**不会**跨 size-class 重用；但**整块 run 回到页池后**，这些页就能被用来供给其它 size-class（见第 3 点）。





## **2) 大对象（走 extent）的碎片重用：**分裂 + 合并（split/coalesce）

- **空闲大块组织**：空闲的物理页区段（extent）按**地址**和**大小**建索引。
- **分配时**：近似 **best-fit** 从空闲集合找最贴近的 extent；不够就从更大的 extent **split** 出所需大小，剩余部分继续留在空闲集合。
- **释放时**：把 extent 放回空闲集合，**尝试与相邻空闲块合并（coalesce）**，尽可能拼成更大的连续块，为下一次大分配做准备。
- **页状态分层**（按“冷热/可回收”程度）：
  - **dirty**：刚释放的页，最快可再次分配；
  - **muzzy**：标记 MADV_FREE 的页，OS 可“懒回收”；再次分配时大概率仍可直接用；
  - **retained**：用 MADV_DONTNEED 主动丢内容的页，RSS 下降，但地址空间关系保留，随时可再申请。

> 这套 **split+coalesce + 多级空闲缓存** 就是大对象“对外部碎片”的消化术。





## **3)** **跨 size-class 的复用**：整块 run 退出 → 页回到“公共池”

- 小对象 run **一旦被完全清空**，对应的页会**从该 size-class 释放**回 arena 的页池（即 extents 层）。

- 这些页随后**可以被任何 size-class 或大对象再次利用**。

  → 这就是“小对象世界里的碎片**如何间接地被其它类别复用**”的途径（先“合成整块”，再返回页池）。





## **4)** **原位扩/缩**（尽量不搬家，减少二次碎片）

- **xallocx/rallocx**：尝试**不搬家**地扩展/收缩现有分配：
  - **小对象**：同一 run 中如果相邻 region 空闲，**原位扩**就能成功；
  - **大对象**：相邻 extent 可合并时也能原位扩；不行才会分配新块并复制。
- **意义**：减少“新分配 + 旧块释放”带来的二次碎片与复制成本。





## **5)** **“冷静期”与后台线程**：既减少 OS 抖动，又让 RSS 回落

- **decay（衰减）策略**：空闲页不会立刻还 OS，而是经历 **dirty → muzzy → retained/purge** 的**渐进**过程（可配置衰减时间），避免抖动负载下频繁“还了又要”。
- **后台清理线程**（可启用）：定期 **purge** 空闲页（MADV_DONTNEED），让 RSS 下降；也会把“太分散的小空闲”逐步转化为“可复用的大块”。
- **复用优先**：在冷静期内，新的同类/近类分配优先**吃掉本 arena 的空闲页**，避免频繁系统调用。





## **6) tcache / 多 arena 的权衡（顺带影响碎片复用效率）**

- **tcache**：线程本地小缓存让“**最近释放**的小块**就地复用**”，减少跨线程争用和中心化锁。这既**加速复用**，也会**短期延迟**空闲块回流到 run/arena（影响 purge/合并速度）。达到阈值会自动刷回。
- **多 arena**：把负载分区，互不抢锁，也把碎片**隔离在各自 arena**。线程很少时，arena 过多会让空闲更分散，降低全局合并效率（默认配置通常是折中值）。





## **7)** **jemalloc 能做到的上限 & Redis 的补刀**

- **分配器不会移动“存活对象”做压实（compaction）**——它只能通过**选择合适 run/extent、分裂/合并、原位扩缩、后台 purge**来**“机会性”消化碎片**。
- **Redis 的 Active Defrag**：应用层“搬家”对象（重新分配并拷贝到新块）→ 让旧 run/extent 变得“更空或全空”，从而 **显著放大 jemalloc 的回收/合并机会**。这就是为什么开启 Active Defrag 往往能把 RSS 拉下来。





### **速记（你可以写到文档里的“补充条目”）**

- **小对象**：位图 run；**先用最满的非满 run**，把空洞集中→整 run 释放。
- **大对象**：**best-fit + split/coalesce**；空闲页按 **dirty/muzzy/retained** 管理，**后台 purge** 回 OS。
- **跨类复用**：**整 run 清空→页回 arena**，可供任意 size-class/大对象。
- **原位扩缩**：xallocx/rallocx 减少搬家与二次碎片。
- **冷静期**：**decay + bg thread** 降抖动，同时让 RSS 逐步回落。
- **上限**：jemalloc不搬活对象；**Redis Active Defrag** 负责“主动搬家”，与 jemalloc 配合效果最佳。