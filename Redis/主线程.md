# **一、一次事件循环里干什么（网络事件）**

> Redis 自己的 epoll/kqueue 事件循环（ae）驱动一切。

1. **接入新连接**

   - accept、创建 client 结构、设置读写事件/超时、握手（TLS/ACL/auth）。

   

2. **读请求**

   - 从 socket 读入 **查询缓冲区**；解析 RESP、做 ACL、找到命令指针。

   

3. **执行命令（单线程）**

   - 调用命令实现：读写键空间/对象（SDS、dict、quicklist、skiplist、rax …）。
   - 可能把客户端转为**阻塞态**（如 BLPOP、XREAD、WAIT、事务 WATCH 等），主线程**不真正阻塞**，只是把这个 client 移出就绪队列，等条件满足再唤醒。

   

4. **复制/持久化传播（写命令后）**

   - 把写命令或变更**追加到 AOF 缓冲**；
   - 把变更**写入复制传播缓冲**，等待发给 replicas（异步）。

   

5. **写回响应**

   - 把回复放到 **输出缓冲**；触发可写事件把数据 flush 到 socket（可用 I/O 线程加速，见下）。

   

6. **杂项**

   - 释放已解除阻塞的客户端、清理超大输出缓冲、slowlog/latency 采样、keyspace 通知等。

> 伪代码直觉：

```java
for (;;) {
  aeProcessEvents();              // 就绪的读/写/定时事件
  handleClientsWithPendingReads();// 解析请求
  processCommandAndReplies();     // 执行命令 + 产生日志/复制/AOF
  flushPendingOutput();           // 回写
}
```



# **二、时间事件（serverCron，默认 ~10Hz，可调** **hz**）

主线程定时跑一批“**渐进式**”任务，每轮只干一点，避免长阻塞：

- **过期键清理（Active expire cycle）**：抽样各 DB 的过期字典，逐步删除超时 key。

- **内存淘汰（Eviction）**：超过 maxmemory 时按策略（LRU/LFU/TTL）驱动逐步淘汰。

- **渐进式 rehash**：对大字典（主键空间/过期字典/数据结构内部 dict）**按步搬桶**。

- **主动碎片整理（Active defrag）**：把对象“搬家”到更紧凑的块，配合 jemalloc 降 RSS。

- **复制维护**：心跳、offset/ACK、部分重同步窗口、无盘复制状态机等。

- **AOF/RDB 状态机**：

  - AOF：把 AOF 缓冲刷到文件；根据策略进行 fsync；检查是否到达**重写**阈值并触发；
  - RDB：定时/手动触发 BGSAVE；管理子进程完成/失败后的收尾。

  

- **集群 / Sentinel**（开启时）：Gossip ping/pong、故障检测、failover 状态推进、槽迁移等。

- **模块/函数定时器**、client 超时回收、统计采样等。





# **三、哪些事主线程**不**亲自做（或只发起）**

- **后台 I/O 线程（bio）**

  - BIO_AOF_FSYNC：AOF 的 fsync 落盘（根据策略可能放后台）。
  - BIO_CLOSE_FILE：关闭大文件等慢系统调用。
  - BIO_LAZY_FREE：懒释放（UNLINK、过期/淘汰的异步 free），避免主线程大批 free() 卡顿。

  

- **子进程**

  - BGSAVE 生成 RDB；
  - BGREWRITEAOF / Redis 7 的 **AOF base 重写**（multi-part AOF）——主线程继续服务，子进程做重写，完毕后原子切换。

  

- **磁盘/网络重活**

  - 无盘复制时，子进程/后台直接把 RDB 经 socket 传给副本；
  - 大量 DEL 改用 UNLINK 由 lazyfree 线程做释放。

  

# **四、Redis 6+ 的**I/O 线程**（可选优化）**

> **命令执行仍然单线程**，I/O 线程只做“搬运工”。

- **读路径**：io-threads-do-reads yes 时，多个 I/O 线程帮忙从 socket **并行读**并解析到查询缓冲。
- **写路径**：I/O 线程并行 **flush** 大量客户端的输出缓冲。
- 目的：在高并发下**降低网络读写对主线程的拖累**，尤其是大回复场景；数据一致性仍由主线程串行执行命令保证。



# **五、主线程的“设计哲学”**

- **单线程执行命令，避免锁**：数据结构都为单线程优化（SDS、dict、skiplist、quicklist、rax…）。
- **长任务拆小步**：rehash、过期、defrag、淘汰、复制维护都做成**增量/抽样**，每轮只干一点。
- **重活异步化**：RDB/AOF 交子进程；大释放交 lazyfree；I/O flush 交 I/O 线程。
- **写后传播**：一次写既要进 AOF 缓冲也要进复制缓冲；再由相应机制异步落盘/发送。





## **一页小抄**

- **网络事件**：接入 → 读请求 → **单线程执行** → AOF/复制传播 → 回写。
- **定时事件**：过期、淘汰、rehash、active defrag、AOF/RDB 状态机、复制/集群维护。
- **后台/子进程**：fsync、lazyfree、BGSAVE、AOF 重写。
- **I/O 线程（可选）**：只管读写 socket，**不执行命令**。