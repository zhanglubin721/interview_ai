# **1) RDB（**Redis DataBase**）（快照）**

- **做法**：周期性把**内存快照**写成一个紧凑的二进制文件（dump.rdb）。启动时直接把 RDB 读回内存。
- **优点**：文件小、**恢复快**；适合冷备/容灾。
- **缺点**：不是实时，快照间隔内的写入可能丢失（取决于 save 策略）。
- 官方概述：Redis 文档将 RDB归为“snapshotting”方案。 







# **2) AOF（**Append-Only File**）（只追加日志）与 AOF 重写**

- **做法**：把**每条写命令**按 Redis 协议**顺序追加**到 AOF 文件；重启时**回放**这些命令恢复数据。 
- **优点**：更强**持久性**（可配每秒/每写同步）。
- **缺点**：文件会越来越大，回放慢 ⇒ 需要**重写**（rewrite）。
- **AOF 重写（BGREWRITEAOF）**：**不**是简单压缩旧日志，而是**基于当前内存数据**重新生成一份“最小恢复集”（如用 SET/HSET 批量指令），因此体积大幅变小。 



## **Redis 7：Multi-Part AOF（多段 AOF）**

- 7.0 起，AOF 被拆成**基线文件（base）+ 增量文件（incr）**，并由 manifest 追踪：

  - **base**：一次重写时生成，**快照化**（可以是 RDB 或 AOF 形式）

  - **incr**：之后的新增写操作增量记录

    好处是重写期间更稳、更易管理与恢复。 

  



## **AOF 重写是怎么“清历史”的**

### **经典 BGREWRITEAOF（≤ Redis 6）**

- **fork 子进程**遍历内存数据集，生成**最小恢复指令集**的新 AOF 文件（如 SET/SADD/ZADD 等一次性建好当前值）。
- 父进程继续对外服务，同时把新写入**一边追加到旧 AOF**、**一边写入“重写缓冲”**。
- 子进程完成后，父进程把缓冲里的增量补到新文件，**原子替换**旧 AOF → 旧历史全清。





### **Redis 7：Multi-Part AOF（更工程化）**

- AOF 被组织成**基线 base + 增量 incr** 两类分段，清单文件（manifest）记录它们。
- 触发重写时生成**新的 base**（常用 **RDB preamble**，即“RDB 作为前导”，加载更快），随后**切分新的增量段**。
- 老的增量段在合并后被**删除**，效果等同“清历史”。

> 直觉：不是把旧日志“压缩压缩”而已，而是**丢弃历史、直接用现在这份数据重写一个起点**。





### **什么时候触发重写（自动/手动）**

- **自动阈值**（常见默认，可按需调）
  - auto-aof-rewrite-percentage（如 100%：体积比上次重写翻倍就触发）
  - auto-aof-rewrite-min-size（如 ≥ 64MB/256MB 才考虑重写）
- **手动**：BGREWRITEAOF
- **推荐**：开启 **RDB 前导**（aof-use-rdb-preamble yes，Redis 7 的 multi-part 默认已是这种思路），**aof-rewrite-incremental-fsync yes** 让重写的 fsync 更平滑。