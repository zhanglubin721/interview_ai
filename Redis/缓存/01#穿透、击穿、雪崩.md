## **1) 缓存穿透（Cache Penetration）**

**定义**：请求的 key **在缓存和 DB 都不存在**，大量请求“直击”DB，缓存永远命不中。

**触发/危害**：恶意构造随机 key、参数校验缺失、抓取不存在用户等 ⇒ DB 被打爆。

**治理手段**

- **布隆过滤器**：在入口判断“很可能存在/一定不存在”。不存在的直接拦截。

```
// Guava 示例
BloomFilter<String> bf = BloomFilter.create(Funnels.stringFunnel(UTF_8), 10_000_000, 0.01);
if (!bf.mightContain(key)) return null; // 直接拒绝/快速返回
```

- > 生产可用 RedisBloom 或自己维护布隆位图。

- **空值缓存（短 TTL）**：DB 查无此 key，写入占位符（如空串）+ 短 TTL（30s~2min），防止反复打 DB。

- **入口校验/鉴权/限流**：过滤明显非法的 id、超范围参数；对异常高 QPS 的来源限流或封禁。

- **灰/黑名单**：对高风险 key 模式直接丢弃。





## *2) 缓存击穿（Cache Breakdown / Dogpile）*

**定义**：**热点 key 过期**的瞬间，成百上千请求并发回源 DB，“打穿”后端。

**触发/危害**：单个超级热点（如首页配置、热榜、商品详情），过期点瞬时洪峰压垮 DB。

**治理手段**

- **互斥重建（singleflight）/分布式锁**：一个线程回源，其它线程等待或快速失败。

```
String cache = redis.get(key);
if (cache != null) return cache;

RLock lock = redisson.getLock("lock:" + key);
if (lock.tryLock(50, 5, TimeUnit.SECONDS)) {   // 等待50ms，租期5s
    try {
        // 双查，避免重复回源
        cache = redis.get(key);
        if (cache != null) return cache;

        String val = db.query(key);
        redis.setex(key, randomTtl(), val == null ? "" : val);
        return val;
    } finally { lock.unlock(); }
} else {
    // 没拿到锁：短暂等待或直接返回兜底
    Thread.sleep(30);
    return redis.get(key); // 再试一次
}
```

- **逻辑过期/异步刷新**：缓存对象内带 expireAt。读到过期也先返回旧值，同时异步刷新，换“强一致”换“稳延迟”。
- **预热/永不过期（或超长 TTL）+ 后台刷新**：对极热点 key，避免自然过期点。
- **多级缓存**：本地 Caffeine + Redis，进一步削峰。





## **3) 缓存雪崩（Cache Avalanche）**

**定义**：**大量 key 在同一时间集中失效**（或缓存集群整体不可用），造成海量请求直击 DB。

**触发/危害**：统一 TTL、整点失效、节点宕机/切换导致“准同时”大量 miss ⇒ 后端雪崩。

**治理手段**

- **TTL 加随机抖动**：避免同刻失效。

```
int baseTtl = 3600;
int jitter  = ThreadLocalRandom.current().nextInt((int)(baseTtl*0.1)); // ±10%
redis.setex(key, baseTtl + jitter, value);
```

- **分片错峰失效/分批刷新**：按业务维度拆分 key 的失效时间。
- **热点永不过期 + 定时刷新**：关键配置/热榜等采用“刷新式缓存”，不靠自然过期。
- **限流/熔断/降级**：雪崩时对读接口限流、返回兜底页/旧数据；对写接口熔断保护 DB。
- **多级缓存/隔离**：本地缓存、只读副本、隔离舱（舱/池化）防止全局共振。
- **监控与预警**：命中率、回源率、锁等待、DB QPS/RT，提前扩容或提升 hz/worker。







## **写入一致性补充（面试常追问）**

- 采用 **Cache-Aside**：**先写 DB，成功后删缓存**（而非先删）。删除失败要**重试/补偿**（如写消息到 MQ 由消费者删，或订阅 binlog 删缓存）。
- **空值缓存**务必短 TTL + 统计，防止污染；与布隆配合效果更好。





## **一句话小结**

- **穿透**：查的都是**不存在**的 key ⇒ **布隆** + **空值缓存** + **入口校验**。
- **击穿**：**单热点过期**瞬间洪峰 ⇒ **互斥重建/锁** + **逻辑过期/预热** + **多级缓存**。
- **雪崩**：**大量同时过期/缓存整体失效** ⇒ **TTL 抖动/错峰** + **限流熔断降级** + **多级缓存与预热**。





如果面试官继续追问实现细节，你可以把上面三段代码/策略顺着“**读写顺序、并发控制、失败补偿、监控**”四条主线展开即可。