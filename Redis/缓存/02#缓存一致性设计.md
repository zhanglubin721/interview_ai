# 延迟双删

下面用“面试作答 + 可落地”的方式把**延迟双删（Delayed Double Deletion）**讲清楚：是什么、解决什么竞态、优缺点、参数/实现建议、与替代方案对比。

## **是什么（一句话）**

**延迟双删**是在 Cache-Aside 模式写路径中，对同一 key **删两次缓存**：

**写 DB 成功后立刻删一次**，**再延迟 δ 毫秒再删一次**，以消除并发读写导致的“旧值被回填”的脏缓存。

常见两种写法（以推荐的顺序为准）：

1. ✅ **先写 DB → 删缓存 → 延迟 δ 再删一次**（建议）
2. ❌ 先删缓存 → 写 DB → 延迟 δ 再删一次（靠“二次删除”弥补“先删”的先天缺陷，不推荐）



## **解决的竞态（两条时序一看就懂）**

### **A. 推荐序（先 DB 后删）仍可能出现的“慢读回填旧值”**

```
t1  读线程R：查缓存 miss → 去查DB（很慢，读到了“旧快照”）
t2  写线程W：写DB新值提交成功
t3  写线程W：删缓存（第一次）
t4  读线程R：把“旧值”写回缓存（回填） ← 脏缓存产生
t5  写线程W：延迟δ后第二次删缓存  → 清掉R刚回填的旧值
```

第二次删除把“慢读回填”的旧值清干净，缩短脏缓存存活时间。



### **B. 错误序（先删后写）的经典脏写（不推荐，但双删能补锅）**

```
t1  写线程W：删缓存
t2  读线程R：缓存 miss → 读DB（此时DB还是旧值）→ 回填旧值
t3  写线程W：写DB新值
t4  写线程W：延迟δ后第二次删缓存  → 清掉旧值
```

这里“双删”是“补救”；根因是“先删后写”的顺序错误。



## **优点**

- **实现简单、无侵入**：对现有 Cache-Aside 写路径加一行“延迟再删”即可。
- **幂等安全**：删两次不会破坏逻辑；即使第一次删失败，第二次还能补上。
- **有效收敛“脏缓存窗口”**：覆盖“慢读回填”“删除失败”等长尾。



## **缺点 / 风险**

- **不能保证强一致**：在第二次删除生效前，仍可能短暂读到旧值（最终一致）。
- **δ 难以精准选择**：过短无效，过长脏数据存活时间变长。业务时延波动大时更难估。
- **额外开销与抖动**：两次删除会增加写放大；热点写多时可能引发更多 miss/重建压力。
- **调度可靠性问题**：若用应用线程定时（ScheduledExecutorService），“应用重启/故障”可能丢失定时任务；需要可持久的延时机制。
- **多实例重复删除**：幂等但会放大 Redis QPS，需要监控。





## **δ（延迟）的取值建议**

- 经验做法：**δ ≈ P99(“一次回源并回填”的耗时)** + 轻微裕量。

  例如常规读 DB + 序列化 + SETEX 的 P99 若 ~80–120ms，可先取 **150–300ms**，按监控调整。

- 若读路径有复杂聚合/跨库/外部依赖，δ 取更大（如 300–800ms）；过大没意义（窗口长），过小无效（覆盖不到慢读）。





## **Java 落地示例（推荐顺序）**

```
@Transactional
public void updateUser(long id, UserDTO dto) {
    // 1) 写DB（事务里）
    userMapper.update(id, dto);

    String key = "user:" + id;

    // 2) 立刻删缓存（幂等）
    redis.del(key);

    // 3) 延迟双删（可持久化的延时通道更可靠，见下）
    delayedDelete(key, 200, TimeUnit.MILLISECONDS);
}

// 简单版：进程级调度（重启会丢，生产不建议单用）
private static final ScheduledExecutorService SES = Executors.newScheduledThreadPool(2);
private void delayedDelete(String key, long delay, TimeUnit unit) {
    SES.schedule(() -> {
        try { redis.del(key); } catch (Exception ignore) {}
    }, delay, unit);
}
```

**生产建议**：把“延迟删”放到**可持久化的通道**：

- MQ **延时消息**（RocketMQ/DelayLevel、RabbitMQ/TTL+DLX、Kafka+定时轮）；
- Redis **延时桶**（ZSET 存 (now+δ,key)；后台轮询到期删除）；
- **事务外盒（Transactional Outbox）+ 定时扫描**：保证任务不丢。



## **与其它方案对比（何时该用谁）**

| **方案**                                        | **一致性**                     | **成本/复杂度** | **适用**                                                   |
| ----------------------------------------------- | ------------------------------ | --------------- | ---------------------------------------------------------- |
| **延迟双删**                                    | 最终一致；短窗口可能旧值       | 低              | 系统简单、写不重、热点有限、无 binlog 能力时的**廉价补丁** |
| **DB→删Cache + binlog 驱动删缓存**（Canal/CDC） | 最终一致，**可靠补偿**         | 中-高           | 主库可靠产出“变更事件”，删缓存**不丢**，推荐               |
| **写穿/写回**（Write-Through/Behind）           | 写穿一致更强；写回吞吐高但复杂 | 中-高           | 依赖缓存层/队列保证；对一致性/吞吐有特殊诉求               |
| **逻辑过期 + 异步刷新**                         | 读不阻塞、旧值可控             | 中              | 强热点、稳定延迟优先（容忍短时旧值）                       |
| **版本号/CAS 回填**                             | 避免“旧值覆盖新值”             | 中              | 回填时带版本，SET 成功仅当版本未变；更“正交”的根治         |

> 如果你们对一致性要求较高、写频繁或热点大，**优先 DB→删Cache + CDC（binlog）补偿**；延迟双删可作为“次优但低成本”的兜底。



## **实战 Checklist**

- ✅ 始终用 **先 DB 后删 cache** 的顺序；双删只做“收敛窗口”。
- ✅ 选择 **δ≈读回填P99**，并**监控**：命中率、回源率、删除QPS、脏读比例。
- ✅ “延迟删”走**持久化通道**（MQ 延时/延时桶/outbox），避免应用重启丢任务。
- ✅ 删除**幂等**、**失败重试**（含指数退避）；必要时加**binlog 补偿**。
- ✅ 热点 key 考虑 **互斥重建** 与 **TTL 抖动**，避免击穿/雪崩的联动风险。

**一句话总结**：**延迟双删**能有效缩短并发下的脏缓存窗口、实现成本低，但**不是强一致**也**不是银弹**。在可行的前提下，更推荐 **“DB→删Cache + CDC 补偿/版本校验”** 作为长期方案，延迟双删作为廉价的工程化补丁使用。







# 广播刷新本地缓存

**读（Cache-Aside + L1/L2）**

1. 先查 **L1 本地缓存**（Caffeine 等）
2. miss → 查 **L2 Redis**
3. 再 miss → 查 **DB**，并**写回 L2**；本地 L1 可按需写回



**写（推荐顺序）**

1. 先**写 DB**（事务内完成业务变更）
2. **删除 L2**（Redis 的该 key）
3. **发布“失效事件”**（MQ/Redis Streams/Redis PubSub）
4. 各节点收到事件后：**删除本地 L1**（可选：后台异步刷新）

> 只发“失效”而不是把新值“推送”过去，能避免版本乱序/大 payload；刷新交给读路径或后台任务完成。





## **二、消息通道选型**

| **方案**                    | **是否持久**       | **顺序**   | **备注**                                                     |
| --------------------------- | ------------------ | ---------- | ------------------------------------------------------------ |
| **Redis Pub/Sub**           | 否（节点离线会丢） | 近实时     | 简单、低延迟；不保证送达，适合可容忍偶丢（有 TTL 兜底）的场景 |
| **Redis Streams（消费组）** | 是                 | 可控       | 轻量持久化、可重放；适合要“保证送达”的失效广播               |
| **Kafka/RabbitMQ/RocketMQ** | 是                 | 分区内有序 | 工程化最好：高可靠、可追溯；写路径接入略复杂                 |

**实践建议**：能上**CDC（binlog）→ MQ**最好（可靠产出变更事件）；否则在应用里“写DB成功后发送消息”，再配 **Outbox**（事务外盒）避免消息丢失。





## **三、事件设计（建议字段）**

```
{
  "type": "CACHE_INVALIDATE",
  "key": "user:123",
  "ns": "user",               // 命名空间/业务域
  "ver": 1730023456789,       // 版本戳：updatedAt/自增version
  "traceId": "..."            // 追踪与排障
}
```

- **幂等**：消费者按 key 删除即可，多次删除无副作用。
- **防乱序**：若做“推新值/刷新”，务必比较 ver，旧版本消息直接丢弃。





## **四、Java 侧示例（精简版）**

**发布方（写路径）**

```
@Transactional
public void updateUser(long id, UserDTO dto) {
    userRepo.update(id, dto);               // 1) 写DB
    String key = "user:" + id;
    redis.del(key);                         // 2) 删L2（幂等）
    eventBus.publish(new InvalidateEvent(   // 3) 广播失效
        "user", key, System.currentTimeMillis()));
}
```

**订阅方（各应用节点）**

```
@EventListener // 或 KafkaListener / Streams consumer
public void onInvalidate(InvalidateEvent e) {
    if (!"user".equals(e.ns())) return;
    localCache.invalidate(e.key());         // 删除L1
    // 可选：后台 singleflight 预热
    // singleFlight.run(e.key(), () -> warmUp(e.key()));
}
```

**读取（带 L1/L2 与 singleflight）**

```
public User getUser(long id) {
    String key = "user:" + id;
    return localCache.get(key, k -> {                   // L1 miss回调
        String json = redis.get(k);                     // 查L2
        if (json != null) return fromJson(json);
        User u = db.find(id);                           // 查DB
        redis.setEx(k, toJson(u), randomTtl());         // 写回L2（带抖动）
        return u;
    });
}
```





## **五、优点 & 风险**

**优点**

- **收敛不一致窗口**：写后立刻广播，L1 很快变“未命中”，下次读会拿到新值。
- **水平扩展友好**：节点越多，广播效果越明显；不需要每个节点都“被动等 TTL”。
- **可与 CDC 结合**：DB 是权威源，binlog 驱动消息更可靠。



**风险/注意点**

- **消息可靠性**：Pub/Sub 离线就丢；要“保证送达”请用 Streams/MQ 或 Outbox。
- **乱序/重复**：按 ver 做比对、按 key 幂等删除 → 设计成 **at-least-once + 幂等**。
- **节点短暂不在线**：恢复后 L1 可能旧；用 **持久通道重放** 或 **进程启动清空 L1**。
- **广播风暴**：高写入量下事件洪峰要限速/合并（按 key 去重、批处理）。
- **兜底策略**：即便有广播，也要保留 **TTL 抖动**、**击穿互斥重建** 等基础措施。





## **六、和其它方案怎么配**

- **替代/互补：延迟双删**

  - 双删是“写后靠时间补刀”，**广播是写后立刻通知**。两者可以并存：广播失败/消息丢时，双删仍能缩短污染窗口。

  

- **CDC（binlog）最优先**

  - 可靠地产生变更事件 → **删 L2 + 广播 L1**，是稳定、工程化最好的一条路。

  

- **逻辑过期 + 异步刷新**

  - 对超热点：L1/L2 都返回旧值，后台刷新；广播可用于触发刷新而非直接删。

  



## **七、快速 Checklist**

- 写路径 **先DB后删L2再发消息**；删除失败要重试/补偿
- 选 **可靠通道**（Streams/MQ/CDC）或接受 Pub/Sub 的“尽力而为”
- 事件幂等 + 版本戳，消费者**按 key 失效**为主
- L1 使用 **singleflight** 预热/互斥重建，L2 设置 **TTL 抖动**
- 监控：命中率、回源率、消息积压、消费延迟、脏读比



**一句话**：订阅/消息通知=“**写后即时广播无效化**”，能显著缩短脏缓存时间；可靠性要靠**持久通道 + 幂等 + 版本化**兜住，和 Cache-Aside 的基础防线（TTL 抖动、击穿互斥）一起使用效果最佳。





# **什么时候值得上“广播刷新本地缓存”（L1 本地 + L2 Redis）**

> 先纠正一下叫法：通常把**本地内存**叫 **L1**，**Redis**叫 **L2**。

**典型触发条件（满足 2~3 条就很有价值）：**

1. **极低延迟诉求**：接口 p99 需要 < 5–10ms，Redis/跨区网络抖动都会显著放大尾延迟；L1 命中可把读延迟压到亚毫秒级。
2. **大规模水平扩展**：N 台应用每台 R rps → 直打 Redis 就是 N×R；加 L1 命中 95% 时，Redis QPS 只剩 5%×N×R，能**省出整片集群成本**。
3. **热点高度集中**：少量 key 被频繁访问（商品详情、榜单、配置）；L1 命中率可轻松 99%+。
4. **跨可用区/跨地域**：跨区 RTT 5–20ms；把读留在本机内存能显著降时延并减带宽费。
5. **Redis 是瓶颈或成本敏感**：读多写少时，广播“失效事件”的开销远小于直打 Redis 的放大。
6. **要抵御雪崩/击穿**：L1 作为第一道缓冲，能把瞬时冲击挡在本机。





**一个“算账”示例**

- 50 台应用 × 2k rps/台 = **10万 rps** 读；

- L1 命中 95% → 只有 **5k rps** 落到 Redis（节省 95%）；

- 假设写 300 rps，广播失效到 50 台 = 15k 次本地删除/秒（**很轻**，而且是内存操作）。

  这类盘子上，引入 L1+广播通常**值回复杂度**。