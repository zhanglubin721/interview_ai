## **争议到底在哪儿？**

### **1) 依赖时间的“租约”语义（时钟漂移 / 进程暂停）**

Redlock靠**TTL 租约**判断锁是否仍然有效；客户端以**本地耗时**去估算“我拿锁时还剩多少有效期”。现实里会出现：

- **GC/STW、容器挂起、系统卡顿**导致客户端“以为还在租期内”，但锁在服务端早就过期，**另一个客户端已拿到** → 两个持有者**并发执行**（安全性破坏/互斥失效）。
- **时钟跳变**（非单调时钟）也会让到期判断出错。Redis 官方文档直言：Redis 的过期机制**不是单调时钟**，墙钟跳变可能让**多进程同时拿到锁**，并建议配**fencing token**等手段兜底。 
- 核心批评（Kleppmann）：在**异步网络 + 进程可暂停**的现实故障模型下，**只靠超时**不能保证互斥；应在被保护资源侧加**栅栏号**（单调递增版本）拒绝过期持有者的写。 



### **2) 网络分区与节点崩溃（落盘与失败顺序）**

- Redlock要求对**多台互相独立的 Redis 主节点**（不是主从复制）取**多数派**来加/续/释锁，目的是避开**异步复制**的“切主丢写”问题；官方也解释了为啥**基于主从故障转移**不足以保证互斥。 
- 但在**分区/抖动 + 进程暂停**叠加下，可能出现：A 在大多数节点上加了锁后**暂停过久**→ 锁到期；B 随后获取锁并执行业务；A 恢复后**仍以为自己持锁**继续写。算法本身并**不阻止**这种跨时间窗口的并发，需要业务侧防护（见“表态”）。这正是“租约”与“强互斥”的**模型差异**。 
- 另外，单机崩溃若**未 fsync**（例如 AOF everysec）可能**丢掉锁键**，增大竞态概率；Redlock文档也讨论了**性能/崩溃恢复/fsync**的取舍。 



### **3) 安全/活性证明的适用边界**

- Redlock文档给出**安全/活性**三性质（互斥、无死锁、容错）与非正式论证；但其**前提模型**与现实系统（时钟、分区、暂停）存在落差，引发学界/工程界质疑。 
- 作者（antirez）给出反驳：“相对单机/主从，Redlock 在现实里**更安全**且更高可用”，但也承认需要按场景权衡。 



## **面试表态（工程位势）**

> **主张**：在常规互联网业务里，**优先“本地原子 + 自动续期 + 限时业务补偿”**，而不是直接上 Redlock。



**落地策略（Java/Redis 实践）**

1. **单实例/高可用 Redis + 看门狗续期**（Redisson RLock）：SET NX PX + 唯一 token + Lua 解锁 + 自动续期，解决“锁早过期”的大部分长尾。
2. **栅栏号（fencing token）**：拿锁时从一个线性递增计数器取号（或用 etcd/ZK 线性化序号），下游**只接受更大版本**写入，从根上挡住“过期持有者继续写”。此点是 Redlock 争议的**共识化补救**。 
3. **限时业务补偿/幂等**：写接口幂等化、可重试；必要时用 WAIT/min-replicas-to-write 降低“刚写就挂”的风险。 
4. **若要强互斥**（线性一致）：**别用锁模拟一致性**，直接用 **ZooKeeper/etcd** 这类共识系统（线性化会话 + 租约 + 顺序号），再配栅栏号。

**何时才考虑 Redlock？**

跨机房容错、**无法**依赖单个高可用 Redis/共识组件、且能接受“租约+栅栏号”的工程语义；否则它的复杂度与争议点**不值当**。





### **一句话记忆**

- 争议核心：**基于时间的租约 + 现实的时钟/暂停/分区** ⇒ 无法单靠 Redlock 证明强互斥；需要**栅栏号**兜底。 
- 面试表态：**优先本地原子锁 + 看门狗续期 + 栅栏号 + 幂等补偿**；要强一致就上 **etcd/ZK**，别把 Redlock 当银弹。