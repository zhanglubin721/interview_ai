# **1. 总览：list 的真实编码是 quicklist（节点里装 listpack）**

- 早期 Redis 的 list 用“**双向链表**”，每个元素一个节点，**指针开销巨大**；
- 之后改为 **quicklist**：**双向链表的每个节点**不是一个元素，而是**一个“紧凑块”**（早期是 ziplist，现在是 **listpack**）——**把许多元素挤在一个连续内存块里**；
- 所以 **list 的唯一底层编码 = quicklist**；而 **listpack 是 quicklist 节点内部的紧凑容器**（对 hash/zset 也被广泛使用）。

**直观图：**

```
quicklist
  ┌───────────────────────────────────────────────────────────────────┐
  │ head ↔ [ quicklistNode ] ↔ [ quicklistNode ] ↔ ... ↔ [ tail ]    │
  └───────────────────────────────────────────────────────────────────┘
              │                          │
              ▼                          ▼
        listpack(紧凑块)            listpack(紧凑块)
       [e1 e2 e3 ... ek]           [e(k+1) ... e(n)]
```

- 每个 quicklistNode 里塞一个 **listpack**，存多条元素；
- 这样既**减少节点/指针数量**（省内存、提高局部性），又保留“块级”的 O(1) 头尾插/删。







# **2. 结构细节**

## **2.1 quicklist / quicklistNode（骨架）**

```
typedef struct quicklistNode {
    struct quicklistNode *prev, *next;
    unsigned char *entry;     // 指向 listpack 的起始地址（或“plain”单元素）
    size_t sz;                // 该 listpack 的字节大小
    unsigned int count;       // 该 listpack 中的元素个数
    unsigned char encoding;   // RAW 或 LZF（是否被压缩）
    unsigned char container;  // PACKED(listpack) 或 PLAIN（单元素直存）
} quicklistNode;

typedef struct quicklist {
    quicklistNode *head, *tail;
    unsigned long count;      // 全部元素个数
    unsigned long len;        // quicklistNode 的数量（块数）
    int fill;                 // “填充策略”：控制每块的大小或元素数
    unsigned int compress;    // “压缩深度”：保留首尾多少块不压缩，其余块 LZF 压缩
} quicklist;
```



- **container**：

  - PACKED：常见情况，节点里是一个 **listpack**（连续内存，紧凑存多元素）；
  - PLAIN：当单条元素**非常大**时，用“单元素直存”的节点，避免把超大值塞进 listpack 里导致搬移成本爆炸；

  

- **encoding**：

  - RAW：未压缩；
  - LZF：节点内的 listpack 被 LZF 压缩为一坨字节（减少内存；访问时临时解压）。



## **2.2 listpack（紧凑块）**

- 一个**连续内存段**，按顺序存放若干 entry；
- 每个 entry 的头部**变长**编码（记录类型/长度），**小整数直接内嵌**（节省内存），字符串按长度用 1~5 字节头；
- 末尾有一个 **backlen**（同样变长），能从尾部**逆向**解析（便于从右边 pop）；
- listpack 头里还带 **总字节数**、**元素个数** 等元信息，扫描和边界判断更快；
- 插入/删除在块内要 **memmove**（移动后面的字节），但由于块不大、命中缓存，常数不高。





# **3. 排序/定位与基本操作的路径**

> list 的语义是**顺序表**（保持写入顺序），不是按 score/lex 排序（那是 zset 的活）。

> quicklist/listpack 只关心**紧凑存储**与**顺序访问**。



### **3.1 LPUSH / RPUSH（头尾追加）**

1. 找到 head/tail 节点；
2. 如果该节点 listpack 还未“满”（见 §4 填充策略）→ **直接 append/prepend** 到这个 listpack；
3. 如果“满了”：
   - 在该侧**新建一个 quicklistNode**，其中创建一个新的 listpack，把新元素放进去；
   - 把新节点串到链表头/尾；
4. count/len/sz 等元数据更新；
5. 若配置了压缩（compress>0），**非边缘**节点可能在空闲时被压缩成 LZF（访问时解压→改→再压）。

**复杂度**：均摊 **O(1)**。块内 append 是 O(1)，偶发新开节点/压缩/解压带来小概率额外开销。



### **3.2 LPOP / RPOP**

- 从 head/tail 节点的 listpack 里**弹出一条**；
- 若该块空了 → **移除整个 quicklistNode**；
- 若中间节点被压缩：先解压该节点（边缘节点一般不压缩，见 compress 深度）。

**复杂度**：均摊 **O(1)**。



### **3.3 LINDEX / LSET（按下标找/改）**

- quicklist 不维护索引树；按**接近的一侧**（头或尾）沿节点走，累计 listpack 的 count，直到落入目标块；
- 在落入的 listpack 内**顺序推进**到第 i 个元素（块内是 O(k) 扫描/跳指）；
- 写时可能触发块内 memmove（改长度不同的值），或块分裂/合并；

**复杂度**：**O(min(i, n−i))** + 块内 O(k)。

**直觉**：别把 list 当“随机访问数组”，它更适合**队列/双端队列**。



### **3.4 LINSERT / LREM / LTRIM（中间插/删/裁剪）**

- 先走到目标块（O(min(i, n−i))），块内插/删 O(k)；必要时可能**分裂**当前块（从中间把一个 listpack 拆为两个）或**与邻块合并**；
- 裁剪（LTRIM）常是**大量删除**，会跨越多个块，但逐块删除/释放连续内存，效率仍然比较好。







# **4.** **节省内存**与**性能**的核心：fill（块大小）+ compress（压缩深度）

## **4.1** **fill**（list-max-listpack-size）：**每块塞多满**

- 作用：控制 **每个 listpack 的目标大小**，从而决定“一个 quicklistNode 装多少元素/多少字节”；

- **两种语义**（取决于配置值的符号）：

  - **正数**：按**最大元素个数**限制（例如每块最多 512 个元素）；

  - **负数**：按**近似字节上限**限制（例如 -2 ≈ 8KB，-3 ≈ 16KB，依版本映射不同，常见默认≈8KB 级别）。

    负值策略更关注“块大小”，能更好地控制块内 memmove 的成本与缓存局部性。

  

- **影响权衡**：

  - **块更大**（更“满”）：**更少节点** → 指针/元数据开销更少，迭代更快；但**块内插删 memmove 更大**；
  - **块更小**：**更多节点** → 指针开销变多，但**单次 memmove 更小**，中间插删更轻。

> 生产里：如果 list 主要是**头尾 push/pop**，块大一点通常更省内存、整体更快；如果大量**中间插删**，块小一点能降低单次移动成本。





## **4.2** **compress**（list-compress-depth）：**压缩深度**

- 表示**两端各保留多少块不压缩**（用于低延迟 push/pop/peek），**中间的块**在空闲时压为 LZF；
- 例：compress=2 → 头部保留 2 块、尾部保留 2 块 RAW，其余块可能 LZF 压缩；
- 访问中间块：
  - 读/改时**临时解压**，改完再**回压**（时间换空间）；
- **默认常为 0（不压缩）**。只有在**超大 list** 且**中间很少访问**的场景，开启压缩能显著降内存。

**压缩的 trade-off：**

- 
  - 优点：大幅减少常驻内存；
- − 代价：访问压缩区域的延迟上升（解压/再压）。







# **5. listpack 的紧凑编码（为啥比“每元素一个节点”省这么多）**

- **连续内存**：消灭了“每元素一个对象/指针”的额外 16~40B+ 开销；
- **变长头**：小整数、短字符串的头很小（1~2 字节），总开销 ~（头几字节 + 数据），密度高；
- **backlen**：支持从右向左扫描，不必给每个 entry 再存“prev 指针”；
- **块级元信息**：知道总字节/元素数，很多操作不用完全遍历即可做边界判断；
- **CPU 缓存友好**：顺序访问命中率高，迭代速度通常远超“链表每节点随机指针”的实现。





# **6. 复杂度小结**

| **操作**     | **复杂度（均摊/常见）** | **说明**                                               |
| ------------ | ----------------------- | ------------------------------------------------------ |
| LPUSH/RPUSH  | O(1) 均摊               | 头尾块直接插入；偶发新建块/分裂/压缩引入小概率额外成本 |
| LPOP/RPOP    | O(1) 均摊               | 头尾块直接弹出；块空则 O(1) 移除节点                   |
| LINDEX/LSET  | O(min(i,n−i)) + O(k)    | 先跨块再块内定位；不适合频繁随机索引                   |
| LINSERT/LREM | O(min(i,n−i) + k)       | 中间插删可能触发块分裂/合并                            |
| LTRIM        | O(#受影响元素)          | 大量裁剪跨多个块，但释放整块效率高                     |
| 遍历         | O(n)                    | 连续内存 + 更少节点 → 常数好                           |

> k 代表“块内位移/移动的元素数”或对应的 memmove 字节规模。





# **7. 调优与实践建议**

1. **面向用法选 fill / compress**

   - **队列/双端队列**（典型：日志队列、异步任务）：

     - fill 取**较大块**（按字节限制的负值，≈8~16KB 是常见折中）；
     - compress 可视数据量开到 1~2，节省中部内存；

     

   - **中间插删较多**：

     - 把 fill 调小（块小），降低一次 memmove 的代价；
     - 通常不建议开启压缩（否则中间访问抖动）。

   

2. **超大元素**使用场景

   - 单条元素很大时节点会切换为 PLAIN 容器（单元素直存），避免把超大数据放进 listpack。
   - 这种场景下压缩可能更有意义（PLAIN + LZF），但注意访问延迟。

   

3. **避免把 list 当数组**

   - 频繁随机索引改用 zset / sorted structure / 或者 hash+有序索引；
   - list 适合**顺序/队列**模型（push/pop、顺序遍历、批量裁剪）。

   

4. **内存观察**

   - MEMORY USAGE key 可看单 key 粗略占用（含结构开销）；
   - 用 INFO memory 或采样查看整体变化，评估压缩/填充策略的收益。

   





# **8. 与 Java 直觉的映射**

- 把 **quicklist** 想成：LinkedList<Chunk>，每个 Chunk 里是一个**紧凑数组**（listpack，像 ArrayList 但更紧凑，且元素是变长编码），并且中间很多 Chunk 可被**LZF 压缩**；
- fill ≈ “每个 Chunk 的最大大小/容量策略”；
- compress ≈ “保留首尾 N 个 Chunk 常驻解压状态，其余懒压缩”。







# **9. 常见问答（面试/排障）**

**Q：为什么不用“纯数组”或“纯链表”？**

A：纯数组随机插删贵；纯链表指针开销大、缓存不友好。quicklist = **块状链表**，两者折中：块内用数组（listpack），块间用链表。



**Q：压缩会不会影响可靠性？**

A：只是内存中的编码方式；持久化（RDB/AOF）保存的是逻辑值。访问压缩节点时临时解压再压回，不影响语义。



**Q：块多大会更好？**

A：没有银弹。**头尾操作为主** → 块大些；**中间操作多** → 块小些。典型经验值在 **8KB~16KB** 一侧比较折中（按负值字节策略）。



**Q：能不能像 zset 那样按 rank 很快定位？**

A：list 没有跳表的 span 概念，**不支持** O(logN) 的 rank 定位；LINDEX 仍是线性跨块。





# **10. 小结（放文档可直接复用）**

- **list 的底层编码是 quicklist**：双向链上挂多个**listpack 块**；
- **listpack** = 连续内存的紧凑容器：小整数内嵌、变长头、末尾 backlen，极大降低 per-element 开销；
- **fill** 控制每块大小/个数（空间 vs 块内 memmove 的权衡）；
- **compress** 控制首尾免压缩的深度，其余块 LZF 压缩（时间换空间）；
- **操作复杂度**：头尾均摊 O(1)，中间 O(min(i,n−i)+块内移动)；
- 适合 **队列/双端队列/顺序遍历/批量裁剪** 场景，**不适合**频繁随机索引；
- 大值用 PLAIN 容器避免把超大 entry 放进 listpack；必要时配合压缩进一步降内存。