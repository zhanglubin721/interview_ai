# **0) 参与者与核心概念**

- **Redo Log（WAL，物理重做日志）**：记录对页的物理修改（page + offset + data），顺序写，崩溃后**前滚**脏页。以 **LSN**（Log Sequence Number）编号，页头也存“该页已应用到的 LSN”。
- **Undo Log**：记录“逻辑反做信息”（每行的老版本 + 回滚指针），用于**回滚未提交事务**，也为 MVCC 提供版本链。
- **Binlog（Server 二进制日志）**：Server 层的**复制/恢复**日志（事务级原子追加）。
- **Doublewrite Buffer（双写缓冲）**：避免 16KB 页**撕裂写**（partial/torn page）。刷脏页时先把页批量写入 doublewrite 区并 fsync，再写到真正位置；恢复时若发现坏页，用 doublewrite 的副本还原。
- **Checkpoint（检查点）**：记录“到此为止，所有修改已持久可恢复”的 LSN；恢复只需从 checkpoint LSN 起扫描 redo。
- **MTR（Mini-Transaction）**：InnoDB 内部的“最小原子修改单元”，其 redo 记录保证要么全部生效，要么全部不生效。





# **1) 事务提交的真实流程（InnoDB ↔ Binlog 两阶段）**

> 以常见的（binlog=ROW/MIXED 均同）“崩溃安全提交”为例：

1. **执行阶段**：更新缓冲页，写 **redo buffer**（内存）。
2. **写入 Undo**：构建行版本链，可回滚。
3. **写 redo 到磁盘文件 ib_logfile\***（追加），根据 innodb_flush_log_at_trx_commit 决定是否 **fsync**。
4. **进入 PREPARE**：在 redo 中记下 “prepared 事务” 的元信息（持久化）。
5. **写 binlog**：把该事务的 binlog 记录写入 **binlog 文件**并（可）**fsync**，sync_binlog 控制是否每次 fsync。
6. **COMMIT 标记**：
   - InnoDB 生成 commit 记录（或将 trx 从 prepared 改为 committed），并**释放行锁**等；
   - binlog 写入 **XID Event**（表示该事务最终提交，复制与崩溃恢复以此为准）。

> 该过程是一个 **协调的 2PC**：**InnoDB 为参与者，Server/binlog 为协调者**。崩溃后以“binlog 是否有 XID”来判定 prepared 事务的命运（见第 3 节）。





# **2) 可能的崩溃窗口 & 后果（在** **正确耐久配置**下）

假设“要做到**已提交不丢（durable）**”，一般要求：

- innodb_flush_log_at_trx_commit = 1（每次提交都把 redo **写盘+fsync**）
- sync_binlog = 1（每次提交都把 binlog **写盘+fsync**）

在此配置下的关键窗口：

| **崩溃点**                                                   | **Redo**         | **Binlog**         | **重启后的结果**                                             |
| ------------------------------------------------------------ | ---------------- | ------------------ | ------------------------------------------------------------ |
| T 在 **PREPARE** 之后、**XID 未写入**                        | 已持久           | 未持久（或无 XID） | 事务被 **回滚**（InnoDB 检测到 prepared 但无 XID，按 2PC 规则回滚） |
| T 在 **Binlog 已持久 + XID 已落盘**，但 InnoDB 最终 commit 记录未落 | 已持久到 PREPARE | 已持久（含 XID）   | 重启时 InnoDB 发现 **prepared** + **binlog 有 XID** → **自动补提交**（前滚 + 提交），对外可见为“已提交” |
| T 在 **两者都已持久（XID + commit）**                        | 已持久           | 已持久             | 重启时直接可见为“已提交”                                     |

> 只要两端都按上面的 fsync 策略，**不会出现“已提交却丢”的情况**。

> 反之：

- > innodb_flush_log_at_trx_commit=2/0 会让 redo 只在每秒/后台刷，宕机可能丢最近 1 秒内**已提交事务**的持久化（对“本机可见性”与“崩溃后可见性”造成影响）；

- > sync_binlog=0 可能导致 **binlog** 丢尾，从而在主从复制/点时间恢复上“看不到”该事务（主库自己可能利用 redo 前滚看到，但复制链路不安全）。





# **3) 重启时的恢复流程（按执行顺序）**

**（0）Doublewrite 修复 torn page**

- 启动时扫描 data file 页的校验与页 LSN；若发现损坏/撕裂，**用 doublewrite 区的副本替换**，保证后续 redo 能正确应用。



**（1）Redo 前滚（Roll-Forward）**

- 从 **checkpoint LSN** 开始扫描 redo log；
- 对每条记载的页修改，加载相应数据页（若页头 LSN < 该 redo 记录 LSN）就**重做**该修改，直至日志尾部；
- 这一步把“崩溃前已写入 redo 的修改”全部补到数据页，确保数据映像至少达到“最后一个可识别的 redo 记录”的状态。



**（2）处理 Prepared 事务（2PC 协调）**

- InnoDB 遍历“**prepared-but-not-committed**”的事务列表：
  - 查 **binlog** 是否存在对应 **XID Event**：
    - 有 → 在 InnoDB 内部**补提交通知**，使其对外成为 **已提交**；
    - 无 → 将该事务 **回滚**（使用 undo）。
- 这一步保证 **InnoDB 与 binlog 的原子一致性**，是“已提交不丢”的关键。



**（3）Crash Rollback（回滚未提交事务）**

- 对**未提交/未 prepare** 的事务，按其 **undo log** 执行逻辑回滚：恢复到“事务开始前”的行版本。
- 行为等价于：宕机瞬间你按了“全部未完成事务回滚”。



**（4）Purge 历史版本**

- 系统启动后，后台 **purge 线程**继续/启动，清理**不再被任何快照需要**的旧版本（undo 残留），释放空间，修复次级索引残留。



**（5）Change Buffer & AHI 等恢复**

- **Change Buffer**（历史名 insert buffer）：次级索引的延迟合并，redo 已记录，重启后继续合并；
- **Adaptive Hash Index**：不持久化，重启重建（不影响一致性）。

> 整体顺序记忆：**双写修页 → redo 前滚 → prepared 判命运 → 未提交回滚 → 后台清理**。





# **4) Checkpoint 与“为什么 redo 能恢复到一致状态”**

- **页头 LSN**：每个页在被修改刷盘时，页头写入“该页已应用到的最大 LSN”。
- **Checkpoint**：记录“到此为止磁盘上的脏页都可由 redo 恢复”的位置。
- **恢复判据**：对页应用 redo 的时候，只在“**页头 LSN < redo 记录 LSN**”时才重做，保证 **幂等** 与 **顺序正确**。
- 因为采用 **WAL** 与 **fuzzy checkpoint**（不要求所有脏页先写盘），崩溃时哪怕大量脏页未落，**只要 redo 持久**，恢复即可前滚到一致状态。







# **5) DDL、复制与更多边角**

- **原子/崩溃安全 DDL（8.0+）**：大部分 DDL 采用 **原子 DDL**（redo/binlog 协同 + data dictionary 事务），崩溃后要么全部可见，要么完全不见；旧版“拷贝算法”DDL 较重且恢复复杂。
- **复制安全**：sync_binlog=1 确保主库崩溃后 **binlog 不丢尾**，从库有完整事件流；结合 innodb_flush_log_at_trx_commit=1，保证主从可达一致。
- **Group Commit**：多事务**拼批写 binlog + 单次 fsync**，同时维护与 InnoDB 提交顺序一致，降低 fsync 开销而不牺牲崩溃安全。







# **6) 配置对“是否丢数据”的影响（速查表）**

| **目标**                  | **必要配置**                                          | **风险说明**                                                 |
| ------------------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| 崩溃后 **已提交绝不丢**   | innodb_flush_log_at_trx_commit=1 **且** sync_binlog=1 | 两端都需要 fsync；否则可能出现“主库本地前滚看见，但 binlog 丢尾、复制丢事务”或“redo 未落导致本机也回退”的情况 |
| 更高性能、可容忍 ≤1s 丢失 | innodb_flush_log_at_trx_commit=2 或 0，sync_binlog=0  | 可能丢最近 1 秒（甚至更多）的提交；**不建议**用于强一致业务  |
| 高端盘替代双写            | innodb_doublewrite=OFF + 原子写盘/闪存 FUA            | 需硬件/FS 支持“页级原子写”，否则风险极高                     |



# **7) 常见面试/实战问答（要点速背）**

- **Q：为什么需要 doublewrite？**

  **A**：单次刷 16KB 页，崩溃可能只写了一部分（torn page）。doublewrite 先把页写到一个连续区域并 fsync，崩溃后若发现坏页，就用那里的“整页副本”恢复，再套用 redo，确保页级一致性。

- **Q：重启时先前滚还是先回滚？**

  **A**：先 **redo 前滚**到最新可恢复的 LSN，再**回滚未提交事务**（用 undo）；对处于 prepared 的，通过 **binlog XID** 决定“补提/回滚”。

- **Q：binlog 有而 InnoDB 没 commit 怎么办？**

  **A**：这就是 2PC 的设计：InnoDB 在重启时发现 prepared 且 binlog 有 XID，会**补交**，保证“已提交不丢”。

- **Q：哪些设置最关键？**

  **A**：innodb_flush_log_at_trx_commit=1 + sync_binlog=1 + **开启 doublewrite**（或具备等效原子写能力），这是强一致生产的“三件套”。







## **一句话总结**

**崩溃恢复的核心是 WAL（redo）+ undo + 双写 + InnoDB↔binlog 的 2PC**：

- **前滚**：从 checkpoint 起用 redo 把数据页补到最新；

- **判决**：对 prepared 事务以 binlog 的 XID 为准决定“补提/回滚”；

- **回滚**：用 undo 清理未提交更改；

- **修页**：用 doublewrite 兜底 torn page。

  只要你在生产上严格使用 innodb_flush_log_at_trx_commit=1 与 sync_binlog=1 并保留 doublewrite，**已提交事务不会因为崩溃而丢失**。