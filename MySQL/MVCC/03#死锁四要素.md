死锁的“四要素”（Coffman 条件）：

1. **互斥（Mutual Exclusion）**

   资源一次只能被一个线程/事务独占。

   例：同一行记录的排他锁 X 锁只能被一个事务持有。

2. **请求并保持（Hold and Wait）**

   进程已获得至少一个资源，同时又去请求新的资源，并在等待期间不释放已持有的资源。

   例：事务 T1 已锁住行 A，又去等行 B 的锁，但不放开 A。

3. **不可剥夺（No Preemption）**

   已获得的资源在使用完前，不能被系统强行剥夺，只能由持有者主动释放。

   例：数据库不会随便把你持有的行锁强制给别人（除非回滚/被选为牺牲者）。

4. **循环等待（Circular Wait）**

   存在一个等待环：T1 等 T2，T2 等 T3，…，Tk 又等 T1。

   例：T1 持 A 等 B；T2 持 B 等 A → 构成环。

> **满足这四个条件，死锁就可能发生**。破坏其中任意一个，死锁就不会产生。





## **在数据库中的直观例子**

```
-- T1
BEGIN;
UPDATE t SET ... WHERE id=1;   -- 锁住行 1
UPDATE t SET ... WHERE id=2;   -- 等待行 2（被 T2 占着）

-- T2
BEGIN;
UPDATE t SET ... WHERE id=2;   -- 锁住行 2
UPDATE t SET ... WHERE id=1;   -- 等待行 1（被 T1 占着）
```

此时：互斥 ✅，请求并保持 ✅，不可剥夺 ✅，形成循环等待 ✅ ⇒ 死锁。

InnoDB 会**死锁检测**，选一方为“牺牲者”回滚释放锁（相当于打破“不可剥夺”）来解开死锁。







## **工程上如何预防（对应打破某个条件）**

- **固定加锁顺序**（破坏循环等待）：所有事务按相同顺序访问资源（如先小 id 再大 id）。
- **一次性申请/短事务**（缓解请求并保持）：尽量在一个短事务里获取所需锁，减少持锁等待。
- **允许“剥夺”**：设置锁等待超时/启用死锁检测，让系统回滚一方。
- **降低互斥冲突**：用更细粒度资源、合理索引让锁更精准（避免大范围/间隙锁），减少相遇概率。

记忆口诀：**互斥、请求且保持、不可剥夺、循环等待**——四者齐备，方有死锁。