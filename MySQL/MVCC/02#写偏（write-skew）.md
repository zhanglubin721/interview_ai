## **先纠正一个前提**

- 在 **InnoDB + RR** 下，**普通 SELECT（快照读）根本不会加任何行锁/间隙锁**；它只是读**事务开始时的快照**。
- **只有锁定读/当前读**（SELECT ... FOR UPDATE/SHARE、UPDATE/DELETE）才会在 **RR** 下加 **next-key 锁（记录锁 + 间隙锁）** 来“堵住别人往范围里插新行”。

所以你说“RR 只是把读到的行锁起来，没有间隙锁”这句，只对**快照读**；对**当前读**不对——当前读在 RR 是有间隙锁的。





## **这类“先查再插”的并发现象叫什么？**

- 你举的：两个事务都用**快照读**检查“是否存在”，都看见“没有”，于是**同时插入**，最后出现“两条都插进去了”。
- 这不是严格意义上的 **幻读（phantom read）**，因为你**没有在同一事务里再次查询并读到“多了的行”**。
- 它的准确名字叫 **写偏（write-skew）**，也常被称作 **check-then-insert race**（先检后插的竞态）。写偏是**快照隔离/RR 快照读**下典型的并发异常之一。

> 幻读：同一事务用**相同条件再次读取**时，“结果集变了”。

> 写偏：两个事务都基于各自**一致性快照**做出**互相冲突的写**，最后破坏跨行/跨范围约束。





## **怎么防这种写偏？**

1. **数据库约束**（首选）：给“唯一性/不重叠”建约束

   - 例：ALTER TABLE oncall ADD UNIQUE(day);
   - 并发只会有一方成功，另一方报重复键。

   

2. **锁定读 + 合适索引**：把“检查那一步”改成 **当前读**

```
SELECT 1 FROM oncall WHERE day = ? FOR UPDATE;  -- RR 下加 next-key 锁
-- 若没查到，再 INSERT
```

1. 需要 day 上有索引且谓词可索引（列上不要函数）。
2. **小范围用 SERIALIZABLE**：把普通 SELECT 也当锁定读处理（最强但最阻塞）。
3. **幂等/上锁式写法**：直接 INSERT ... ON DUPLICATE KEY UPDATE / INSERT IGNORE，让数据库做仲裁。





## **记忆版**

- **快照读**：不加锁 → 不会“读到幻行”，但**会发生写偏**。
- **当前读（RR）**：有 **next-key** → 能**阻止**别人插入范围内的新行，消除幻。
- 你说的并发插入案例：**不是幻读/幻写**，而是**写偏（write-skew）**。