先把结论挑明白：

- **不是“只要用 JOIN 就一定更快”**。
- 之所以**常常更快**，是因为 **MySQL 优化器会把很多子查询（IN/EXISTS、相关子查询）改写成“连接型”的执行**：要么变成**半连接（semi-join）**，要么**去相关化后做一次性 JOIN/预聚合**。这样能少走弯路、少做重复工作、让索引/连接算法生效。

下面用“为什么快 + 两个小例子 + 什么时候不一定快”说明白。





## **为什么“连接型”的执行通常更快**

1. **把 N 次变 1 次（去掉 per-row 子查询）**

   相关子查询等价于“外层每行跑一次内层查询”。去相关化后变成一次 JOIN/聚合，复杂度从

   O(N_outer × cost(inner)) → O(cost(all) + join)，通常显著下降。

2. **优化器能做更多事**

   

   - **半连接（IN/EXISTS）策略**：FirstMatch（命中即停）、Duplicate Weedout（先去重）、LooseScan（跳跃式索引扫描）、Materialize（先物化再连）……都比“每行子查询”高效。
   - **选择连接顺序**：挑最小/最容易过滤的表做驱动表。
   - **访问路径优化**：用 **索引嵌套循环**、**BKA**、甚至 **Hash Join（8.0.18+）**。
   - **谓词/列下推**：把过滤条件、投影列**推到数据更近的地方**（DCP、ICP、列裁剪），减少读取与回表。
   - **早停**：EXISTS/半连接命中一行即可返回（不用全扫）。

   

3. **更容易充分用索引**

   显式的等值连接键（r.k = l.k）+ 合适索引，让“按键找行”的成本变成 O(log N)，而不是“兜一圈再比”。







## **例子 1：**IN (subquery)**→ 半连接（EXISTS）**

**原始**

```
SELECT o.*
FROM orders o
WHERE o.user_id IN (SELECT u.id FROM users u WHERE u.status='A');
```

**优化后（等价语义，半连接执行）**

```
SELECT o.*
FROM orders o
WHERE EXISTS (
  SELECT 1
  FROM users u
  WHERE u.id = o.user_id AND u.status='A'
);
```

**为什么快**

- 右表 users(id, status) 有索引时，半连接能用 **FirstMatch/LooseScan**，只要确认存在就停；而不是把子查询对外表每行跑一遍。
- 计划里你会看到 semi join 的字样（EXPLAIN FORMAT=TREE/JSON）。







## **例子 2：相关标量子查询 → 预聚合 + JOIN（去相关化）**

**原始（每行算一次）**

```
SELECT p.id,
       (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) AS c_cnt
FROM post p;
```

**改写**

```
SELECT p.id, COALESCE(cc.c_cnt, 0) AS c_cnt
FROM post p
LEFT JOIN (
  SELECT post_id, COUNT(*) AS c_cnt
  FROM comment
  GROUP BY post_id
) cc ON cc.post_id = p.id;
```

**为什么快**

- comment(post_id) 有索引时，内层只聚合一次，再按键 JOIN；从 “N 次 COUNT” 变“一次 GROUP BY + N 次按键匹配”。
- EXPLAIN 不再出现 DEPENDENT SUBQUERY，总体 rows 与时间陡降。







## **但也**不是“JOIN 永远更快”——这些情况可能**一样快**甚至更慢

- **小常量列表**：col IN ('A','B','C') → 用 JOIN 反而啰嗦。
- **优化器已经做了相同的改写**：MySQL 8 对 IN/EXISTS 常自动半连接化，写法不同性能可能一样。
- **索引缺/类型不匹配**：JOIN 键没索引、或两端类型/字符集不一致，会触发 Using join buffer（块嵌套循环），可能更慢。
- **JOIN 产生大中间结果**：为了等价语义不得不 DISTINCT/聚合 去重，可能多一次排序/临时表。
- **复杂 NOT IN + NULL 语义**：要严格保持三值逻辑，简单替换会改变结果；需 NOT EXISTS + <=> 或先去 NULL。







## **实战建议（怎么写更稳）**

1. **IN/EXISTS 场景**：

   - 优先写 **EXISTS**（语义明确，规避 NOT IN 的 NULL 坑）；
   - 确保**被驱动表**（子查询/EXISTS 里的表）的**连接键有索引**；复合键就写多列等值。

   

2. **相关子查询**：

   - 能改成**预聚合 + JOIN**或**窗口函数**就改；
   - 给“分组键/排序键”建索引，如 (post_id)、(user_id, create_time DESC)。

   

3. **确认优化器是否替你做了**：

   - 看 EXPLAIN FORMAT=TREE/JSON 是否出现 semi join、FirstMatch/LooseScan/Duplicate Weedout；
   - 看是否不再是 DEPENDENT SUBQUERY；
   - EXPLAIN ANALYZE 检查 loops 是否从“≈外层行数”降到 1。

   







### **一句话收尾**

> JOIN/半连接/去相关化之所以常更快，不是“JOIN 这个语法魔法”，而是它**把计算变成一次性的、可用索引/可早停/可下推的集合操作**，避免了“每行再跑一次”的重复工作。前提仍是**索引正确、类型匹配、写法可优化（SARGable）**。





## **LooseScan（跳跃式索引扫描）**

### **它在干嘛（一句话）**

**LooseScan 是半连接的一种执行策略**：当你写 IN (subquery) / EXISTS 时，优化器不去把子查询结果 DISTINCT 物化，也不对外表每行做一次“探测”，而是**沿着内表的索引，只取每个“连接键组”的第一条记录，然后“跳到”下一组**——相当于“索引层的去重 + 扫描”，再与外表做连接。



> 关键词：**每个连接键只访问一次**、**利用索引有序性跳过重复**、**减少读放大与临时表**。





### **何时适用（判定规则 + 索引模式）**

LooseScan 典型适用的 IN/EXISTS 形态：

```
SELECT ... FROM L
WHERE (L.k1, L.k2, ...) IN (
  SELECT R.k1, R.k2, ...
  FROM   R
  WHERE  <只依赖 R 的过滤>
);
```

**内表 R 需要有这样一棵索引**（左前缀有序）：

```
INDEX( <只依赖R的过滤列...>, k1, k2, ... )
```

- “只依赖 R 的过滤列”放在前面（等值/范围都可），**连接键列** k1,k2,... 紧随其后；
- 这样优化器可以在索引里**先定位过滤范围**，然后在该范围内**按 (k1,k2,…) 的分组顺序跳跃**，每组只取第一条。

> **什么时候收益大**：子查询内表 **对同一连接键有很多重复行**（我们只关心“存在与否”），LooseScan 就能跳过大量重复。





### **直观例子（一步步看它“跳哪里”）**

**需求**：找出有“活跃会话”的用户的订单。

```
-- 原始写法（IN 子查询）
SELECT o.*
FROM orders o
WHERE o.user_id IN (
  SELECT s.user_id
  FROM sessions s
  WHERE s.active = 1
);
```

**索引**（给内表 sessions）：

```
CREATE INDEX idx_s_active_user ON sessions(active, user_id);
```

**LooseScan 执行过程（概念化）**：



1. 在 idx_s_active_user 上先定位 active=1 的索引区间；
2. 在这个区间里，按 user_id 的有序性，**只取每个 user_id 的第一条**（跳过同一用户的其余会话行）；
3. 把这些 **去重后的 user_id** 流式地与外表 orders 做连接（ref/eq_ref）——这就实现了“半连接”。

**对比其它策略**

- **Materialize**：先建临时表 SELECT DISTINCT user_id FROM sessions WHERE active=1 再连（需要写临时表）。
- **Duplicate Weedout**：扫描时用去重结构（哈希/临时表）过滤重复键。
- **FirstMatch**：以外表为驱动，对每个外表行探测内表“命中即停”，重复探测很多次。
- **LooseScan**：**不探外表 N 次，也不建 DISTINCT 临时表**，直接靠索引“跳组”输出唯一键。





### **多列连接键的例子**

```
-- 需求：orders 的 (user_id, region_id) 出现在活跃会话里
SELECT o.*
FROM orders o
WHERE (o.user_id, o.region_id) IN (
  SELECT s.user_id, s.region_id
  FROM sessions s
  WHERE s.active = 1
);

-- 内表索引（过滤列在前，连接键紧随）
CREATE INDEX idx_s_active_user_region
ON sessions(active, user_id, region_id);
```

LooseScan 会在 active=1 的索引区间内，按 (user_id,region_id) 分组，每组只触达一次。





### **如何识别它生效了**

- EXPLAIN FORMAT=TREE/JSON：在半连接节点一侧，通常能看到 **LooseScan** 的字样（不同版本呈现略有差异，但会标注所用的半连接策略）。
- 现象层面：相比 Materialize/Duplicate Weedout，**临时表/去重的代价下降**；相比 FirstMatch，**对外表的探测次数减少**。
- ANALYZE：内表的实际扫描行明显少于“内表满足过滤条件的总行数”（因为跳过了重复）。





### **什么时候用不上 / 不一定更快**

- **连接键唯一**（例如 users(id)）：本来就没有重复，LooseScan与其它策略效果差不多，甚至 FirstMatch 就足够了。
- **索引列顺序不匹配**：内表索引没有把“过滤列在前、连接键在后”排好，无法“在正确的范围里跳”。
- **子查询还有 GROUP BY/LIMIT/DISTINCT 特殊语义**：可能转为其它策略或物化。
- **过滤列是复杂函数/不可 SARGable**：无法用索引界定范围，只能全扫或退化策略。





### **如何“扶一把”（让它更可能被选上）**

1. **为子查询内表建立匹配索引**：INDEX(<R过滤>, join_key...)。
2. **把连接键写成多列等值**（元组）而不是函数/表达式：(r.k1,r.k2) = (l.k1,l.k2)。
3. **避免子查询里无意义的 ORDER BY/DISTINCT**（只判断存在不需要），减少物化倾向。
4. **必要时用 EXISTS 写法**：语义直接，方便优化器选择半连接策略。
5. **观察计划**：若仍选不到，可比较 Materialize/Duplicate Weedout 的代价，或调整索引列顺序/统计信息。



### **小结（记忆版）**

- **LooseScan = 利用内表索引“对连接键分组跳跃”**，每个键只触达一次；
- 适合 **内表重复多、只需“存在性”** 的 IN/EXISTS；
- 索引模式：**内表索引 =（子查询过滤列…, 连接键…）**；
- 相比 Materialize/Duplicate Weedout/FirstMatch，LooseScan 常**更省临时表或探测次数**，但**前提是索引对路**。