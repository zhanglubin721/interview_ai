“每行都有子查询”通常指**相关子查询（correlated subquery）**：外层表的每一行，都要把该行某些列当参数去跑一次内层 SELECT。这类写法可读，但常导致**N 次重复工作**（N≈外层候选行数），容易慢。优化总思路是：**去相关（de-correlate）→ 变成一次性 JOIN / 聚合 / 窗口函数**，并给对的索引。



下面按最常见 5 类场景给出**改写模板 + 索引建议 + 验证点**。





## **1) 标量查找（按外键取一个字段）**

**Before**

```
SELECT o.id, o.user_id,
       (SELECT u.vip_level FROM user u WHERE u.id = o.user_id) AS vip
FROM orders o
WHERE o.create_time >= ?;
```

**After（等价 JOIN，一次性）**

```
SELECT o.id, o.user_id, u.vip_level AS vip
FROM orders o
LEFT JOIN user u ON u.id = o.user_id
WHERE o.create_time >= ?;
```

**索引**

- user(id)（PK）已有即可；若是其他键查字典，确保**被驱动表**的连接键有索引。

  **验证**

- EXPLAIN 不再出现“子查询块”；type 期望 eq_ref/ref，无 Using join buffer。







## **2) 每行做聚合（计数/求和/最值）**

**Before**

```
SELECT p.id,
       (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) AS c_cnt
FROM post p WHERE p.status=1;
```

**After A（预聚合派生表 + JOIN）**

```
SELECT p.id, COALESCE(cc.c_cnt,0) AS c_cnt
FROM post p
LEFT JOIN (
  SELECT post_id, COUNT(*) AS c_cnt
  FROM comment GROUP BY post_id
) AS cc ON cc.post_id = p.id
WHERE p.status=1;
```

**After B（窗口函数，MySQL 8）**

```
SELECT DISTINCT p.id,
       COALESCE(COUNT(c.id) OVER(PARTITION BY p.id), 0) AS c_cnt
FROM post p
LEFT JOIN comment c ON c.post_id = p.id
WHERE p.status=1;
```

**索引**

- comment(post_id)；如按时间还要过滤/排序，加 (post_id, create_time) 复合。

  **验证**

- EXPLAIN 不再出现“每行执行一次”的子查询；扫描行从“p 行 × 平均子查询成本”降为“comment 一次聚合”。







## **3) 每行取“最新一条/Top-1”**

**Before**

```
SELECT u.id,
       (SELECT c.content
        FROM comment c
        WHERE c.user_id = u.id
        ORDER BY c.create_time DESC
        LIMIT 1) AS last_comment
FROM user u;
```

**After A（预聚合 + 回连原表）**

```
-- 先算每个 user 的最大 create_time，再回表取整行
WITH last_ct AS (
  SELECT user_id, MAX(create_time) AS max_ct
  FROM comment GROUP BY user_id
)
SELECT u.id, c.content
FROM user u
LEFT JOIN last_ct lc ON lc.user_id = u.id
LEFT JOIN comment c
  ON c.user_id = lc.user_id AND c.create_time = lc.max_ct;
```

**After B（窗口函数）**

```
SELECT u.id, c.content
FROM user u
LEFT JOIN (
  SELECT user_id, content, create_time,
         ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY create_time DESC) AS rn
  FROM comment
) c ON c.user_id = u.id AND c.rn = 1;
```

**索引**

- (user_id, create_time DESC)；Top-1 取值时能少排序/少回表。

  **验证**

- EXPLAIN 里不应再看到子查询物化/重复执行；filesort 降低或消失。







## **4) 存在性判断（EXISTS / IN）**

**Before（相关子查询）**

```
SELECT o.*
FROM orders o
WHERE EXISTS (
  SELECT 1 FROM refund r
  WHERE r.order_id = o.id AND r.status = 'DONE'
);
```

**After（半连接/显式 JOIN）**

```
SELECT DISTINCT o.*
FROM orders o
JOIN refund r ON r.order_id = o.id AND r.status = 'DONE';
```

> MySQL 8 通常会把 EXISTS/IN 自动改写成**半连接**；但显式 JOIN 有助于你**控制索引与过滤顺序**。

> **索引**

- refund(order_id, status)；至少 refund(order_id)。

  **验证**

- EXPLAIN 看到 join，不再是 DEPENDENT SUBQUERY；Using join buffer 消失。







## **5) 反存在（NOT IN/NOT EXISTS）与 NULL 坑**

**Before**

```
SELECT u.*
FROM user u
WHERE u.id NOT IN (SELECT user_id FROM order WHERE status='PAID');
```

**After（反连接）**

```
SELECT u.*
FROM user u
LEFT JOIN (
  SELECT DISTINCT user_id FROM `order` WHERE status='PAID'
) o ON o.user_id = u.id
WHERE o.user_id IS NULL;
```

> 或直接 NOT EXISTS (SELECT 1 FROM order o WHERE o.user_id = u.id AND o.status='PAID')（MySQL 会做反半连接）。

> **索引**

- order(user_id, status) 或至少 order(user_id)。

  **验证**

- 结果正确且避开 NULL 导致的 UNKNOWN；计划为反连接而非每行子查询。







## **6) 其他高频花样的替代写法**

- **子查询里提取 JSON 路径**：用**生成列 + 索引**或 JSON_TABLE() 展开后 JOIN。
- **派生表外层再过滤**：把外层条件**写进内层**，让 DCP 下推/或直接合并。
- **子查询里做 DATE(col)=?**：改**范围谓词**，保证可索引（SARGable）。







## **索引与写法 checklist**

- **连接键**两端类型/字符集一致，并在**被驱动表**上有索引。
- 预聚合用的键要建索引（如 child(parent_id)），避免全表分组。
- 对“Top-1 per group”建 (group_key, order_key DESC) 复合索引。
- 写法保持 **SARGable**：列不上函数；时间用范围；大偏移分页改 keyset。
- EXPLAIN 关注：不再出现 DEPENDENT SUBQUERY、Using join buffer；rows 显著下降；FORMAT=JSON/TREE 可见半连接/合并；必要时用 EXPLAIN ANALYZE 看实际行数/loops。







## **什么时候“保留子查询也行”？**

- 子查询能被优化器**去相关**或**半连接化**（IN/EXISTS 常见），且 EXPLAIN ANALYZE 显示实际 loops≈1（不是外层行数倍增）。
- 子查询结果集很小且有良好索引，整体代价可接受。

> 但在**复杂报表/高并发**场景，显式改写成 JOIN/预聚合/窗口函数通常更稳、更可控。