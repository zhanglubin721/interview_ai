# **1) 半连接（semi-join）**

**是什么**

当你写 IN (subquery) 或 EXISTS (subquery)，优化器把它**改写成一种特殊的 JOIN**：只关心“**是否存在匹配行**”，而**不把右表的行拼到结果里**。这叫 *semi-join*（半连接）。



**为什么有用**

- 避免“外层每行执行一次子查询”（N 次）；
- 可以用 JOIN 的各种策略/索引，扫描量大幅下降。



**在 MySQL 里的常见策略（EXPLAIN/TREE/JSON 能看到）**

- **FirstMatch**：右表命中第一行就停（存在性成立即返回）。
- **Duplicate Weedout**：先把右表可能匹配的键去重，再和外表匹配。
- **LooseScan**：利用右表有序索引跳跃式扫描，跳过大量不可能的键。
- **Materialize**：把子查询结果先物化（临时表）再做半连接。



**可手写的等价改写**

```sql
-- IN
SELECT * FROM orders o
WHERE o.user_id IN (SELECT id FROM users WHERE status='A');

-- EXISTS 等价
SELECT * FROM orders o
WHERE EXISTS (
  SELECT 1 FROM users u
  WHERE u.id = o.user_id AND u.status='A'
);
```

> 右表（users）的**连接键必须有索引**，否则容易退化为块嵌套循环（Using join buffer）。

**NOT IN 的 NULL 坑**

NOT IN (subquery) 一旦子查询产出 NULL，整体会变 UNKNOWN → 常常全表 0 行。实务里改**NOT EXISTS**或在子查询里显式 IS NOT NULL。



# **2) 优化器内联（inlining / derived-merge）**

**对象**

FROM (SELECT ... ) AS dt 的**派生表**、**视图**、以及**非递归 CTE**。

**做了什么**

能合并时，优化器把派生表/视图/CTE **“并回”外层查询**，当作一条更大的查询来优化（谓词可以下推到原表、可少一次物化/临时表）。这常被叫做 **derived-merge / inlining**。

合并不了，就会 **物化（materialize）**，在 EXPLAIN 里常见 select_type=DERIVED/MATERIALIZED。



**什么时候更可能内联**

- 派生表**没有** DISTINCT / GROUP BY / HAVING / WINDOW / LIMIT 等会改变行数或顺序的要素；
- 外层只做过滤/联接，且条件可以**下推**到派生表里（DCP：Derived Condition Pushdown）；
- 同一个 CTE/派生表**只使用一次**（多次复用时，物化反而更划算）。



**鼓励内联的小技巧**

- 去掉派生表里的 ORDER BY（除非配 LIMIT 真有语义）；
- 把外层的过滤**写进内层**（等价条件下推）；
- 若只是为了可读性用 CTE/子查询，不要引入会阻碍合并的语法。

**例子**

```sql
-- 原：FROM 子查询 + 外层过滤
SELECT dt.user_id, dt.amount
FROM (SELECT user_id, amount, status FROM orders) AS dt
WHERE dt.status=1;

-- 内联后（等价）
SELECT user_id, amount
FROM orders
WHERE status=1;
```

这样索引（orders(status, ...)）能直接生效；若物化，中间表还要落地/扫描一次。



# **3) 去相关化（decorrelation）**

**是什么**

把**相关子查询**（内层引用外层列）改写成**等价的 JOIN / 预聚合 / 窗口函数**，消除“外层每行跑一次”的代价。

**三类高频改写**

1. **存在性判断（EXISTS/IN）→ 半连接**

   已在上面讲过。把：

```
WHERE EXISTS (SELECT 1 FROM r WHERE r.k = l.k AND r.flag=1)
```

改写成 JOIN 语义（优化器也会自动做）并确保 r(k, flag) 有索引。

1. **标量子查询（每行算一个聚合）→ 预聚合 + JOIN**

```sql
-- Before：每行一个相关子查询
SELECT p.id,
       (SELECT COUNT(*) FROM comment c WHERE c.post_id=p.id) AS cnt
FROM post p;

-- After：一次聚合再回连
SELECT p.id, COALESCE(cc.cnt,0) AS cnt
FROM post p
LEFT JOIN (
  SELECT post_id, COUNT(*) AS cnt
  FROM comment GROUP BY post_id
) cc ON cc.post_id = p.id;
-- 索引：comment(post_id)
```



1. **Top-1 per group（相关子查询 + ORDER BY LIMIT 1）→ 窗口函数或“最大值再回连”**

```sql
-- Before
SELECT u.id,
       (SELECT c.content FROM comment c
        WHERE c.user_id=u.id
        ORDER BY c.create_time DESC LIMIT 1) AS last_comment
FROM user u;

-- After A：窗口函数（MySQL 8）
SELECT u.id, c.content
FROM user u
LEFT JOIN (
  SELECT user_id, content, create_time,
         ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY create_time DESC) rn
  FROM comment
) c ON c.user_id=u.id AND c.rn=1;

-- After B：最大时间再回连
WITH last_ct AS (
  SELECT user_id, MAX(create_time) AS max_ct
  FROM comment GROUP BY user_id
)
SELECT u.id, c.content
FROM user u
LEFT JOIN last_ct lc ON lc.user_id=u.id
LEFT JOIN comment c
  ON c.user_id=lc.user_id AND c.create_time=lc.max_ct;

-- 索引：comment(user_id, create_time DESC)
```

**什么时候去不掉相关性**

- 内层用了非确定性/顺序相关的函数（RAND()、LIMIT 强依赖外层顺序且无法等价表达）；
- 语义依赖**每行不同的 LIMIT/OFFSET** 且不能等价表达为窗口函数；
- 复杂的 NOT IN + NULL 语义要求“严格等价”，需要小心改成 NOT EXISTS + <=>。





# **4) 怎么“看见它发生了什么”（EXPLAIN 观察点）**

- **半连接**：FORMAT=TREE/JSON 里出现 semi join、FirstMatch、Duplicate Weedout、LooseScan；select_type 不再是 DEPENDENT SUBQUERY。

- **内联 vs 物化**：

  - 被合并：FROM <derived> 不见了，外层的条件出现在内层 attached_condition；
  - 被物化：select_type=DERIVED/MATERIALIZED，可能看到 Creating tmp table、Using temporary。

  

- **去相关化**：相关子查询块消失，变成 JOIN + GROUP；ANALYZE 的 loops 不再≈外层行数。





# **5) 实战小抄（怎么写）**

- **能 EXISTS 就 EXISTS**（尤其替代 NOT IN）。

- 子查询里**不要对连接键做函数/计算**（破坏索引与改写）。

- 复合键就写**多列等值**（a.k1=b.k1 AND a.k2=b.k2），帮优化器选对索引。

- 派生表/CTE仅为可读性时：**避免 ORDER BY/LIMIT/DISTINCT**，利于内联；

  真要复用同一结果多次：**允许物化**，并确保派生表结果有正确索引。

- 对“每行聚合/Top-1 per group”：优先用**预聚合 + JOIN**或**窗口函数**，并给**分组键/排序键建索引**。





**一句话收尾**

- **半连接**：把 IN/EXISTS 变 JOIN 的“存在性”版本，关键是**右表索引**。

- **内联**：让派生表/视图/CTE并回外层，**少一次物化**，条件可**下推**。

- **去相关化**：把相关子查询改写成**JOIN/预聚合/窗口函数**，从“N 次”变“一次”。

  配合对的索引与 SARGable 谓词，就能把复杂 SQL 的复杂度从“指数级放大”拉回到“线性级”。