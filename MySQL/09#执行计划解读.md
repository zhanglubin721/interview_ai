# **0. EXPLAIN 的几种形态（先选工具）**

- EXPLAIN SELECT ...;（表格版）：最常用，适合“快速看索引与连接顺序”。
- EXPLAIN FORMAT=JSON SELECT ...;：含 cost_info、used_key_parts、attached_condition 等细节。
- EXPLAIN FORMAT=TREE SELECT ...;（8.0.16+）：树形、易读，能看出 join 顺序/半连接变换等。
- EXPLAIN ANALYZE SELECT ...;（8.0.18+）：**真实执行**并输出“实际行数/时间/loops”，定位误差和瓶颈最可靠。





# **1. 表格版列的“正确读法”（高频且关键）**



| **列名**          | **怎么看**                                         | **说明 & 典型含义**                                          |
| ----------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| **id**            | 从大到小/同值自上而下                              | 查询块或子查询序号；一般**行的顺序≈实际访问顺序**（注意派生表/子查询会单独编号）。 |
| **select_type**   | SIMPLE/PRIMARY/DERIVED/UNION/SUBQUERY/MATERIALIZED | DERIVED=派生表；MATERIALIZED=子查询被物化；PRIMARY=最外层。  |
| **table**         | 看是否是物理表/别名/<derivedN>/<subqueryN>         | <derivedN> 表示访问的是派生表结果；别名能判断驱动表/被驱动表。 |
| **type**          | **最重要之一**（访问方式）                         | 从好到坏：system > const > eq_ref > ref > range > index_merge > index > ALL。ALL=全表扫；index=全索引扫；ref/range 多见；eq_ref 常见于主键/唯一键等值 join。 |
| **possible_keys** | 只看“有没有你期待的那个”                           | 候选索引列表；**不代表**一定会用。                           |
| **key**           | **实际使用的索引**                                 | 看是否用到了预期索引；配合 JSON 的 used_key_parts 判断用了复合索引的哪些列。 |
| **key_len**       | 判断“复合索引用到哪一列截止”                       | 显示实际用到的索引前缀字节数；能间接看出是否“卡在范围列”。   |
| **ref**           | 常量/列/函数                                       | const/func/db.tbl.col，说明和谁作比较（等值/引用列）。       |
| **rows**          | **估算扫描行数**                                   | 越小越好；是“扫描候选行数”，不是返回行数。                   |
| **filtered**      | 过滤比例（%）                                      | rows × filtered% ≈ 进入下一步的行数。估算偏差大 → 统计信息问题。 |
| **Extra**         | 关键信号灯                                         | 常见：Using where（还有残余谓词）、Using index（覆盖索引）、Using index condition（**ICP**）、Using temporary（临时表，多见 GROUP BY/DISTINCT）、Using filesort（排序未走索引）、Using join buffer（无合适 join 索引，回退块嵌套循环）、Range checked for each record（很差，逐行试索引）。 |

> 快速诊断口诀：**type** 看访问方式、**key/key_len** 看是否命中复合索引、**rows/filtered** 粗估工作量、**Extra** 找大头（filesort/temporary/join buffer/ICP）。







# **2. EXPLAIN ANALYZE：用“真数字”校准“估算”**

- 输出中包含每一步的：actual time（首次/总时长）、rows（实际行数）、loops（循环次数）。
- 看法：
  - **估计 vs 实际**：如果 estimated rows（EXPLAIN）与 actual rows（ANALYZE）差距巨大（10×、100×），优化器可能选错路径 → 补统计或改写谓词/索引。
  - **哪个节点慢**：看“某节点 total time 最长”的那一行，通常是排序/临时表/回表过多/外连接放大。
- 典型修复：ANALYZE TABLE 刷新统计；对低选择性列建**直方图**（UPDATE HISTOGRAM ... WITH 256 BUCKETS）；或改写成 SARGable。







# **3. 三类高频场景的“样板解读”**

## **3.1 等值 + 范围 + 排序（应使用复合覆盖索引）**

**SQL**

```
SELECT id, amount, create_time
FROM orders
WHERE user_id = ? 
  AND create_time >= ? AND create_time < ?
ORDER BY create_time DESC, id DESC
LIMIT 50;
```

**理想 EXPLAIN**

- type=range 或 ref；key=idx_user_ct_id；**key_len** 覆盖 user_id + create_time；

- rows 较小；Extra 不应出现 Using filesort/Using temporary，有可能出现 Using index（覆盖）。

  **解读**

- 范围一旦出现在 create_time，复合索引**后面的排序列**id 仍可用于**消除 filesort**（只要排序方向一致）。

- 若看到 Using filesort，多半是**索引列顺序/方向**不一致或缺少末尾排序列。





## **3.2 LIKE 前缀 + 额外列过滤（触发 ICP）**

**SQL**

```
SELECT id FROM user_profile
WHERE last_name LIKE 'Li%' AND first_name = 'Lei';
-- 索引：(last_name, first_name)
```

**EXPLAIN**

- type=range；key=idx_ln_fn；Extra=Using index condition（**ICP**）。

  **解读**

- 范围来自 last_name 前缀；first_name 不能并入范围 → 在索引层用 ICP 先筛，再回表，回表次数明显下降。

- 若 Extra 没有 Using index condition 且回表很多，可能未开启 ICP（5.6+ 默认开）或选择了错误索引。





## **3.3 GROUP BY / DISTINCT 出现临时表与 filesort**

**SQL**

```
SELECT user_id, COUNT(*) 
FROM orders 
WHERE status = 1 AND create_time >= ? 
GROUP BY user_id
ORDER BY COUNT(*) DESC
LIMIT 20;
```

**常见 EXTRAs**

- Using where; Using temporary; Using filesort。

  **解读与优化**

- 典型报表型：若能把 WHERE 的高选择性列前置并建立 (status, create_time, user_id) 索引，可**减少参与分组的行数**；

- ORDER BY COUNT(*) 无法通过索引消除 filesort → 接受排序或做**预聚合/物化表**。









# **4. 连接顺序与 Join 优化信号**

- **顺序**：表格版自上而下≈实际 join 顺序；TREE/JSON 能更清楚显示（如 Nested loop join 的子树）。
- **Using join buffer**（Block Nested Loop）：被驱动表的 join 条件**没有合适索引**，导致把外表一批批放进内存缓冲再扫内表。→ 给被驱动表的连接键建索引（等值/前缀匹配）。
- **eq_ref**：被驱动表通过主键/唯一键等值命中，一行对一行，**最优**的 join。
- **半连接（IN/EXISTS 改写）**：TREE/JSON 会看到“semi join / duplicate weed-out / first match”等字样，说明优化器把子查询转成高效 join 了。
- **Range checked for each record**：为外表每行临时试索引，性能差 → 明确补对的索引或重写谓词。







# **5.** **key_len**与 **used_key_parts**（判断“用到哪一列”）

- **key_len** 是**实际使用的索引前缀字节数**：

  例如 (user_id BIGINT, create_time DATETIME, id BIGINT)，若等值到 user_id + 范围在 create_time，则 key_len ≈ 8 + 5(+null位)，通常**到范围列为止**。

- **used_key_parts**（JSON）直接告诉你用了哪些列：["user_id","create_time"]。

- 通过它们判断**是否充分利用了复合索引**；若只用到第一列，考虑**索引列顺序**是否应调整。







# **6. Extra 里每个关键信号怎么处置（速查）**

- Using where：仍有**残余谓词**要行级判断 → 尽量把可索引的条件前移/下推，或覆盖索引减少回表。
- Using index：**覆盖索引**，无需回表 → 优。
- Using index condition：**ICP** 生效 → 优（减少回表）。
- Using temporary：使用内存/磁盘临时表（多见 GROUP BY/DISTINCT）→ 考虑复合索引（分组列在后、过滤列在前）、或预聚合。
- Using filesort：排序未走索引 → 让 ORDER BY 与索引顺序/方向一致；或接受排序成本。
- Using join buffer：被驱动表无合适索引 → 给 join 键建索引。
- Select tables optimized away：常见于 MIN/MAX/COUNT(*) 等被简化 → 很好。
- Impossible WHERE：谓词恒 false → 0 行返回（多为逻辑/参数问题）。







# **7. DCP/派生表与物化（两点就够）**

- select_type=DERIVED/MATERIALIZED：说明子查询/派生表**未被合并**，可能**物化**（建临时表）。
- FORMAT=JSON 里若看到外层条件出现在内层的 attached_condition，说明 **DCP**（下推）生效；物化行数下降。

> 能合并最好（derived-merge）；实在要物化，尽量让内层先过滤（把谓词写进内层）。







# **8. 一套“5 步读计划”的固定流程（实战）**

1. **先看 Extra 是否有大红灯**：Using filesort/temporary/join buffer。
2. **看 type/key/key_len**：是否命中预期索引、复合索引是否用到“范围列为止”。
3. **看 rows/filtered**：扫描规模与过滤比例是否合理（>10^6 基本要警惕）。
4. **FORMAT=JSON/TREE**：确认 join 顺序、used_key_parts、是否 semi-join/是否 DCP。
5. **EXPLAIN ANALYZE**：用“实际行数/时间”验证估算；若偏差大 → ANALYZE TABLE/直方图或改写谓词。







# **9. 小例子：从“慢计划”到“好计划”**

**Before（慢）**

```
SELECT * 
FROM orders 
WHERE user_id = ? AND DATE(create_time) = ?
ORDER BY create_time DESC
LIMIT 50;
-- EXPLAIN: type=ALL, key=NULL, rows=几百万, Extra=Using where; Using filesort
```

**问题**：列上函数破坏可索引性 + 排序走 filesort。



**After（快）**

```
-- 复合索引
CREATE INDEX idx_u_ct_id ON orders(user_id, create_time DESC, id DESC);

-- 改写谓词（SARGable）
SELECT id, amount, create_time
FROM orders
WHERE user_id = ?
  AND create_time >= ? AND create_time < ? + INTERVAL 1 DAY
ORDER BY create_time DESC, id DESC
LIMIT 50;

-- EXPLAIN: type=range/ref, key=idx_u_ct_id, Extra=Using index 或 Using index condition（无 filesort）
```







# **10. 常见误解更正**

- **possible_keys 多不等于好**：只表示“理论可用”。看 key 才是真实选择。
- **rows 不是返回行数**：是**扫描候选行**。返回行≈rows×filtered%。
- **Using filesort 不一定很糟**：小表/少量记录排序成本可接受；真正重要的是**规模**。
- **“看到 index_merge 就很棒”？**：不一定，index_merge 往往比一个好复合索引差。能用单个复合索引就别依赖 merge。