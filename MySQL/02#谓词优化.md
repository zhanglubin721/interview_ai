## **定义（一句话）**

在 MySQL/SQL 里，**谓词（predicate）就是一个返回 TRUE / FALSE / UNKNOWN 的布尔表达式**，常出现于 WHERE / ON / HAVING / CHECK 等处，用来筛选行或确定联接条件。因为有 NULL，SQL 采用三值逻辑：当结果为 UNKNOWN 时，WHERE 阶段等同于不匹配。



## **常见谓词类型（带要点）**

- **比较类**：=, <>, <, <=, >, >=, BETWEEN … AND …, <=>（<=> 为 *NULL-safe equal*）。
- **集合类**：IN / NOT IN（注意：NOT IN 遇到 NULL 会变成 UNKNOWN，优先用 NOT EXISTS）。
- **存在类**：EXISTS / NOT EXISTS（相关子查询常被半连接优化）。
- **模式匹配**：LIKE 'abc%'（可走前缀索引）、REGEXP（通常不可走索引）。
- **空值/布尔**：IS NULL / IS NOT NULL、IS TRUE/FALSE。
- **JSON/GIS/全文**：JSON_CONTAINS() / MEMBER OF()、ST_Contains()、MATCH … AGAINST 等。





## **优化相关的几个术语（面试/实战高频）**

- **SARGable（可用索引的谓词）**

  形如 col {=, >, >=, <, <=, BETWEEN} ?、col LIKE 'prefix%'。**列在左、常量在右**，列上**不做函数/计算**，可驱动索引范围/等值访问。

  反例：DATE(col)=?、col+1=?、LIKE '%kw%' —— 索引通常失效或仅部分可用。

- **索引谓词 vs 残余谓词（residual predicate）**

  由索引直接过滤的条件叫**索引谓词**；其余在取到行后再判断的叫**残余谓词**（增加回表/CPU）。

- **谓词选择性（selectivity）**

  匹配行数占比，越低越好。优化器用统计信息/直方图估计选择性来选访问路径。

- **谓词下推（predicate pushdown）**

  把过滤尽量前移：

  - **ICP**（Index Condition Pushdown，5.6+）：在**索引层**就判断部分谓词，减少回表。
  - **DCP**（Derived Condition Pushdown，8.0+）：把外层条件下推到**派生表/子查询**内部。
  - 半连接/子查询去相关化也属于把过滤“推早、推近数据”的范畴。

  



## **写谓词的实务准则（超精简清单）**

1. **列不做函数/计算**：把 DATE(col)=? 改成 col >= ? AND col < ?+1d。
2. **类型匹配**：INT 列用数值参数，DATETIME 用时间参数；避免隐式转换。
3. **前缀可索引**：LIKE 'abc%' 可用，'%abc' 不可。
4. **OR 拆解**：两侧各能走索引时，用 UNION ALL 拆开常更稳。
5. **NOT IN → NOT EXISTS**（防 NULL 坑）。
6. **JOIN 谓词在 ON 中尽早过滤**，连接键两端类型/字符集一致。
7. **分页谓词用“锚点”**：(order_time, id) < (?, ?)，配合复合索引。





### **小例子（SARGable vs 非 SARGable）**

```
-- 好：索引范围 + 可能覆盖
WHERE user_id = ? 
  AND create_time >= ? AND create_time < ?
  AND title LIKE CONCAT(?, '%');

-- 坏：列上函数与前导通配符
WHERE DATE(create_time) = ? 
  AND title LIKE CONCAT('%', ?, '%');
```

**一句话收尾**：

“谓词”就是**条件表达式**。写好谓词=让优化器**早过滤、少扫行、用上索引**；关键是**SARGable**、**类型匹配**、**尽量下推**。



# ICP（Index Condition Pushdown，5.6+）**

**它在干嘛？**

把**能用索引记录里的列**判断的那部分谓词，下推到**存储引擎在扫描二级索引叶子**时就做判断，提前过滤，**减少回表**（按主键去聚簇索引取整行）的次数。

**什么时候有用？**

- 你选用的索引只能用到**前缀的一部分**做范围/等值，而**后面的索引列**条件不能并入“索引范围”，就会变成**残余谓词**。ICP 可以在**索引层**先用这些列把候选进一步筛小，再去回表。
- 仅能用于**当前使用的索引中“可见”的列**（二级索引记录=二级键列 + 主键列）。不能用表里其他未入索引的列。

**怎么识别？**

EXPLAIN 的 Extra 会出现 **Using index condition**。



## **例子 A：范围遇到“后置列”筛选**

表与索引：

```
CREATE TABLE orders (
  id BIGINT PRIMARY KEY,
  user_id BIGINT,
  create_time DATETIME,
  status TINYINT,
  KEY idx_u_ct_status (user_id, create_time, status)
);
```

查询：

```
-- 等值 + 范围 + 再加一个“后置列”筛选
SELECT id
FROM orders
WHERE user_id = ?
  AND create_time > ?
  AND status = 1;
```

- 组合索引的使用规则是：**一旦出现范围列**（这里是 create_time > ?），**其后的列**（status）就**不能再并入“索引范围”**。
- **无 ICP**：引擎按 (user_id=?, create_time>?) 做索引范围扫描，对每个候选 **回表** 再由 SQL 层判断 status=1。
- **有 ICP**：引擎在**索引叶子**就能看到 status（它在索引记录里），直接先判 status=1，**只对满足的记录回表**。
- EXPLAIN 会见到 type=range，Extra: Using index condition；回表次数显著降低。



## **例子 B：LIKE 前缀 + 后缀筛选**

```
CREATE TABLE user_profile(
  id BIGINT PRIMARY KEY,
  last_name VARCHAR(50),
  first_name VARCHAR(50),
  city VARCHAR(50),
  KEY idx_ln_fn (last_name, first_name)
);

-- 只用 last_name 前缀能形成范围；first_name 条件成“残余”
SELECT id FROM user_profile
WHERE last_name LIKE 'Li%' AND first_name = 'Lei';
```

- 索引范围来自 last_name LIKE 'Li%'。
- first_name='Lei' 不是范围前缀的一部分 → **ICP** 会在索引扫描时先判断它，减少回表。

> 反例：city='Beijing' **不在**当前使用的索引记录里，ICP **不能**在索引层判断它。



# **DCP（Derived Condition Pushdown，8.0+）**

**它在干嘛？**

把外层对**派生表/子查询/视图**的过滤条件**下推**到它们的**内部查询**里，尽量让**内层更早过滤**，从而减少**物化/扫描/分组**的工作量。

**什么时候有用？**

- 你的查询写成了 FROM (SELECT ... FROM t ... ) AS dt WHERE dt.col … 的形式；
- 或在**视图**/CTE 外层再加过滤；
- 条件对语义是**等价可下推**的（不跨聚合、不打破 LIMIT/窗口函数语义等）。



**怎么识别？**

- EXPLAIN FORMAT=JSON 里能看到内层 attached_condition/condition 出现了外层的谓词；
- 物化行数明显变少（rows/rows_examined 下降）。





## **例子 C：外层过滤下推到派生表**

```
-- 订单大表，派生表里先做了时间过滤
SELECT dt.id, dt.user_id, dt.amount
FROM (
  SELECT id, user_id, amount, status
  FROM orders
  WHERE create_time >= '2025-01-01'
) AS dt
WHERE dt.user_id = 42 AND dt.status = 1;
```

- **无 DCP**：先物化 create_time>=... 的大结果，再在外层筛 user_id=42 AND status=1。
- **有 DCP**：把 user_id=42 AND status=1 **合并**进内层的 WHERE，相当于：

```
SELECT id, user_id, amount, status
FROM orders
WHERE create_time >= '2025-01-01'
  AND user_id = 42
  AND status = 1;
```

- 物化/扫描的行数立降。





## **例子 D：对分组派生表的下推**

```
-- 每个用户的最近下单时间，再外层按 user_id 过滤
SELECT * FROM (
  SELECT user_id, MAX(create_time) AS last_ct
  FROM orders
  GROUP BY user_id
) AS g
WHERE g.user_id = 42;
```

- **有 DCP** 时，可把 user_id=42 **下推到内层**，等价于：

```
SELECT MAX(create_time) AS last_ct
FROM orders
WHERE user_id = 42
GROUP BY user_id;
```

- 这样 GROUP BY 只在单个用户上做，代价大幅降低。
- 若外层条件引用**聚合后的别名**（如 last_ct > ...），通常**不能**直接下推（会改变语义）。





## **例子 E：视图/CTE 的过滤下推**

```
CREATE VIEW v_paid_orders AS
SELECT id, user_id, amount FROM orders WHERE status = 1;

-- 外层再加 user_id 过滤
SELECT * FROM v_paid_orders WHERE user_id = 42;
```

- DCP 会把 user_id=42 **与视图定义合并**，避免先把所有已支付订单铺开再过滤。

> **不会下推的典型情况**：

- > 外层有 LIMIT/OFFSET、窗口函数、DISTINCT 与内层结构组合后会改变结果的；

- > 非确定性函数（如 RAND()）相关条件；

- > 语义不等价的场景，优化器会选择不下推（保证正确性优先）。



# **如何辨别 ICP、DCP 是否生效？**

- **ICP**：

  - EXPLAIN 的 Extra 出现 **Using index condition**；
  - rows（或 rows_examined）与回表次数下降（看 handler_read_key/next、Innodb_rows_read）。

  

- **DCP**：

  - 用 EXPLAIN FORMAT=JSON，查看内层查询是否多了外层的条件（attached_condition）；
  - 观察派生表物化/分组之前的 rows 是否明显变小。

  

- **ICP** = 在**索引扫描阶段**就把“还能用索引记录判断”的**残余谓词**筛掉，**少回表**。
- **DCP** = 把外层条件**推到子查询/派生表/视图内部**，让内层**更早过滤**，**少物化、少分组**。

