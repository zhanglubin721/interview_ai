# 货源主键反爬改造

## 核心思路：

1.使用预生成的雪花 ID 替代原本数据库层面的自增 ID

2.货源相关 web 服务接口入参和返参均不使用 雪花srcMsgId，而是使用另外一个BizID 传递给 App 或者当做 App 的请求参数

3.找货阶段的所有列表（找货大厅、找货记录等）列表额外返回 token 字段（token 跟用户和货源相关），找货阶段调用详情接口会校验 token 是否合法、履约阶段调用详情接口直接判断是否承运、短信 push 站内信跳转详情自带一个这个货源的通用 token（只跟货源相关，与用户无关）

4.网关层面数据记录用于分析用户是否疑似或确认为爬虫行为并做出反应



## 一、整体分层思路 & 实施顺序



**目标**可以拆成三层：

1. **标识层**：

   - 内部：雪花 ID（方便预生成、跨系统传递）
   - 外部：BizID（不可直接枚举、不可直观看到业务量）

   

2. **访问控制层（资源级）**：

   - 列表返回 token
   - 详情接口必须带 token 才能查（找货阶段必须有 token、履约阶段直接查这个人是否承运）

   

3. **行为风控层（主体级）**：

   - 网关日志 + 统计 + 识别爬虫
   - 疑似 → 人机校验
   - 确认 → 直接封禁

   

**实施顺序（推荐）：**

1. **Phase 1：标识层改造**

   1.1 上雪花 ID（内部发号）

   1.2 新增 BizID 字段 + 对外全部改用 BizID

2. **Phase 2：资源级访问控制**

   2.1 找货阶段所有列表为每条货源生成 detailToken，短信 push 站内信使用该货源的通用detailToken

   2.2 详情接口要求 bizId + detailToken（找货阶段必须有 token、履约阶段直接查这个人是否承运）

3. **Phase 3：行为风控**

   3.1 网关记录访问日志（userId/deviceId/IP/goodsId）（使用 app 传递的时间戳，防止弱网批量重试）

   3.2 每秒/分/小时/日统计访问量 & 无效货源访问（每秒最多 3 次，每分钟最多 60 次，每小时最多500 次，每日最多 2000 次，可根据账号配置）

   3.3 风控策略产出“疑似 / 确定”状态 → 推到 Redis 黑名单 / 灰名单

4. **Phase 4：网关强制动作**

   4.1 疑似用户：网关返回特殊 code 驱动 App 弹人机校验

   4.2 确定爬虫：网关直接封禁（拒绝关键接口）

下面按这个顺序展开说。



## 二、Phase 1：ID 预生成 + BizID 对外暴露

### 1. 雪花 ID（内部主键/业务 ID）

**设计要点：**

- 表结构示例：

```
goods_id BIGINT PRIMARY KEY,   -- 雪花 ID（内部主键）
-- 如果现在是自增主键，需要迁移；暂时可以先加一个字段过渡
```

- ID 生成方式：

  - 用统一组件（如：Leaf / UidGenerator / 自研 Snowflake）；
  - 每个实例有自己的 workerId；
  - 明确“时间回拨处理策略” & “单机 QPS 上限”（之前聊过）。

  

**使用方式：**

- **插入前生成**：
  - 在 service 写库前先生成雪花 ID；
  - 同时可以提前把这个 ID 传给别的系统（MQ、ES、缓存 key）。
- 所有内部关联 / 日志 / 链路追踪里，**用雪花 ID** 作为货源的唯一标识。

> 这一层更多是为了跨系统、分布式发号、解耦 DB 自增，不直接参与防爬。



### 2. BizID：对外暴露的不可枚举 ID

**目标：**

对 App / 第三方 **不再暴露内部雪花 ID**，只暴露一个 bizId（加密/编码后的 ID），提升遍历难度。

**表结构：**

```sql
goods_id BIGINT PRIMARY KEY,             -- 内部雪花 ID
biz_id   VARCHAR(32) UNIQUE NOT NULL,    -- 对外 BizID
```

**生成方式（推荐两种）：**

1. **加密型 bizId：**

   - bizId = Base62( AES(goods_id + salt) )
   - AES 密钥 & salt 存在服务端（Nacos/KMS），不下发到 App
   - 服务器端解：goodsId = AES_DECRYPT(Base62Decode(bizId))

   

2. **随机型 bizId：**

   - 直接生成 128bit 随机数 → Base62 编码成 20 字符左右；
   - 在 DB 建唯一索引保证不重复；
   - 需要额外存映射：biz_id → goods_id。

**对外接口规范：**

- 列表 & 详情 &分享链接等，**全部只用 BizID**：

```json
{
  "bizId": "A8fd2DkLf32",
  "title": "xx货源",
  ...
}
```

```java
public class GoodsVO {

    @JsonIgnore
    private Long srcMsgId;   // 内部用，但不参与 JSON

    private String bizId;   // 对外用的 ID

    private String title;
}
```

**服务端处理：**

- 入口层（网关或 goods-service）统一做一层转换：

```
bizId → goodsId（内部雪花 ID）→ 后续查询
```

controller 层所有的 VO 不允许让原始货源 ID 参与序列化，并且 controller 层所有查询接口必须提前把bizId 转为srcMsgId 后再传递给 service 层（使用 redis 缓存加速）

## 三、Phase 2：列表 token + 详情接口校验

> 这里是核心：即使别人拿到 bizId，也必须有“合法来源的 token”才可以查详情。

### 1. 列表生成 token

**列表接口返回结构：**

```
{
  "bizId": "A8fd2DkLf32",
  "detailToken": "eyJhbGciOiJIUzI1NiIs...",
  "title": "钢材运输",
  ...
}
```

**detailToken 生成方式（推荐无存储、带签名）：**

- 类似 JWT 或自定义 HMAC：

```
payload = {
    userId,          // 当前用户
    bizId,           // 货源 bizId
    exp: 过期时间戳  // 比如 +10分钟
}
token = HMAC-SHA256(serialize(payload), serverSecret)
```

- 最终可以序列化为：

  - base64(payload) + "." + base64(sign)
  - 或用现成的 JWT（HS256）。

  **特点：**

- 无需存入 Redis（无状态），只要签名正确 & 未过期，就认为 token 合法；
- 即使被抓包，过期后 token 也失效。



### 2. 详情接口参数 & 校验流程

**接口参数：**

```
GET /goods/detail?bizId=xxx&detailToken=yyy
```

或 body 里传：

```
{
  "bizId": "xxx",
  "detailToken": "yyy"
}
```

**校验逻辑（可在网关或 goods-service 入口）**：

1. **验签解 token：**

   - 用 serverSecret 验签；
   - 验证签名正确；
   - 解析 payload 得到：userId, bizId, exp。

   

2. **校验与当前请求一致：**

   - 当前登录用户 userId_cur 必须 == token 里的 userId；
   - 请求参数中的 bizId 必须 == token 里的 bizId；
   - 当前时间 < exp（未过期）。

   

3. **通过后：**

   - 再去做 bizId → goodsId 的转换；
   - 查询详情。

   

4. **任何一步不通过：**

   - 返回特定错误码（如：ERR_DETAIL_TOKEN_INVALID）
   - 这类错误也可以作为风控信号，计入“异常行为”统计。

> 结果：

- > 想查详情，**必须先走列表拿合法 token**；

- > 爬虫如果脱离列表、直接构造 bizId 去打详情，会被挡在 token 校验这一层。



## 四、Phase 3：网关行为识别 + 访问量统计 + 疑似/确定爬虫标记

> 这里是你说的整套“异常识别 + 多维统计”落地版。

### 1. 网关记录 & 实时统计

**在网关 filter 里为详情接口做：**

- 日志（写入 MQ/日志系统）：

  每次 /goods/detail 请求写一条：

```
ts, userId, deviceId, ip, bizId, goodsId(可选), resultCode, isValidGoods(是否存在该货源)
```

- 同时更新 Redis 计数，用于实时限流和行为统计：

```
# 访问次数计数
detail:cnt:s:uid:{userId}    # 过去1秒访问次数
detail:cnt:m:uid:{userId}    # 过去1分钟访问次数
detail:cnt:h:uid:{userId}    # 过去1小时访问次数
detail:cnt:d:uid:{userId}    # 过去1天访问次数

# 无效货源（不存在的id/超范围id）
detail:invalid:m:uid:{userId}
```



实现方式可以是：

```
incr(key);
if (first) expire(key, windowSize);
```





### 2. 异常行为识别策略（可在近实时任务里执行）

用 Flink/流式 or 定时任务 + Redis 统计组合：

**典型规则：**

- **高频访问：**

  - 1分钟内 detail:cnt​m:uid:{userId} > 200 → 高频行为；

  

- **无效数量：**

  - invalidCount > 1；

  

- **不走列表：**

  - 最近10分钟没有列表访问，但详情访问频率很高；

  

- **访问 goodsId 分布异常（线性递增/跨度极大）：**

  - 从日志流里做 goodsId 方差/跨度分析（这可以放到稍后做）。

  

**风控结果写回：**

- 疑似爬虫：

```
risk:uid:{userId} = SUSPECT (TTL=1h 或 1d)
```

- 确定爬虫：

```
risk:uid:{userId} = CONFIRMED (TTL=7d or 永久)
```

同样对 deviceId、IP 也有：

```
risk:dev:{deviceId} = SUSPECT/CONFIRMED
risk:ip:{ip}        = SUSPECT/CONFIRMED
```





## 五、Phase 4：网关对“疑似 / 确定爬虫”的实际动作

> “疑似 → 人机校验”

> “确定 → 封禁”





## 六、几句总结（方便你写到文档里）

你可以把你这套方案对外总结成：

- > **标识层**：内部用雪花 ID 作为货源主键，支持预生成与跨系统传递；对外统一暴露 BizID（加密/编码 ID），避免通过线性 ID 直接推测业务规模与枚举资源。

- > **访问控制层**：所有列表接口仅返回 BizID 和短期有效的 detailToken；详情接口必须携带 bizId + detailToken，token 通过 HMAC/JWT 绑定用户和具体货源并设置过期时间，从而强制调用路径为“列表 → 详情”，有效阻断脱离业务路径的暴力遍历。

- > **行为风控层**：在网关统一记录货源详情访问日志，按 userId/deviceId/IP 维度统计每秒/分/小时/日访问量及无效货源访问次数，并结合高频访问、高 404 比例、不走列表等特征识别疑似爬虫与确定爬虫。疑似用户通过返回特殊错误码驱动 App 端进行人机校验，通过后降低风控等级；确定爬虫则在网关层直接封禁账号/设备/IP，拒绝核心接口访问。