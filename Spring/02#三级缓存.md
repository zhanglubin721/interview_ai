# **先看 3 级缓存分别是什么**

Spring 在 DefaultSingletonBeanRegistry 里维护了三张表（再加上一些辅助标记）：

singletonObjects（一级缓存）

- 含义：**完全初始化好的单例**（属性注入 + 初始化回调都完成，能直接对外用了）。
- 时机：initializeBean 之后放入。
- 读取：getSingleton(name, true) 首先查这里。



earlySingletonObjects（二级缓存）

- 含义：**“提前曝光”的早期引用**（early reference），用于正在创建中的 Bean 被别的 Bean 依赖时先顶上一个“半成品”。
- 关键：这个“半成品”可以是**原始对象**，也可以是**已经包了一层代理的早期对象**（见下文 getEarlyBeanReference）。
- 时机：当别的 Bean 依赖我时，且我还没完全初始化，就会把**早期引用**放进来，避免再次走 singletonFactories 反复创建。



singletonFactories（三级缓存）

- 含义：ObjectFactory<?> 工厂，**用于按需生成“早期引用”**。
- 时机：createBeanInstance 之后、populateBean 之前，就把这个工厂登记进去；一旦有人来依赖我，就用它**生成**一个 early reference 并转存到二级缓存。
- 重要：这里面“生成早期引用”的过程会调用各类 SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference，**有机会在早期就创建 AOP 代理**（这就是“提前暴露代理”的核心）。



> 辅助标记

- > singletonsCurrentlyInCreation：记录**正在创建**的单例名，防止重复创建 & 协助判断是否需要 early reference。

- > alreadyCreated 等：生命周期控制，不展开。





# **为什么能解循环依赖？（A ↔ B 的经典路径）**

假设 A 和 B 都是 **singleton**，并且是**字段 / setter 注入**（非构造器注入）：

1. 创建 A：

   - createBeanInstance(A)：先**只实例化** A（构造方法执行），此时属性还没注入。
   - 将 A 的 ObjectFactory 放入 **三级缓存** singletonFactories，记录 A “正在创建”。

   

2. populateBean(A) 需要注入 B：

   - 发现依赖 B，去 getBean(B)。
   - B 不在一级缓存，于是开始创建 B；同样步骤：**实例化 B**，把 B 的工厂放入三级缓存。

   

3. populateBean(B) 又要注入 A：

   - 再次 getBean(A)，发现 A “正在创建”。
   - 走 getSingleton(A, allowEarlyReference=true)：
     1. 一级没有（还没初始化完）；
     2. 二级也没有；
     3. **三级有工厂**，于是调用这个工厂**生成 A 的 early reference**（关键：这里会让后处理器有机会**提早创建 A 的代理**），把结果放进**二级缓存**，并把对应工厂从**三级**删掉。
   - B 拿到的 A 就是**早期引用**（可能已是代理）。于是 B 的属性注入能继续，B 最终完成初始化，放入**一级缓存**。

   

4. 回到 A 的注入继续完成，A 初始化也结束，放入**一级缓存**。

   - 如果 A 的 early reference 是代理，那么 A 的**最终对外暴露的也是同一个代理**（避免“有的地方拿到代理、有的地方拿到裸对象”的不一致）。

> 这套流程的关键在于：**当出现循环依赖，且依赖方允许取“早期引用”时，先用二级缓存的 early reference 解套**；而“早期引用”的来源就是三级缓存里的 ObjectFactory——**它能在非常早的时刻就把代理建好**，从而**统一全局使用同一个代理对象**。





# **为何“必须提前暴露代理”？**

有两个核心原因：

**统一语义（避免“有的拿代理、有的拿目标”）**

- 假如 A 需要被 AOP（比如 @Transactional、@Async、切面）代理，而 B 在 A 完全初始化之前就拿到了 A 的**原始对象**，那么 B 调用 A 的方法会**绕过切面**，行为与系统其他地方（通过容器正常拿到代理再调用）**不一致**。
- 通过 getEarlyBeanReference 在**三级缓存阶段就生成“代理版的早期引用”**，B 注入到的 A 就是**同一个代理**，一致性得以保证。



**避免最终替换对象造成的引用分裂**

- 如果早期注入给 B 的是 A 的**裸对象**，而 A 最终完成后被**包装成代理**放入一级缓存，则容器外部新查到的是**代理**，而 B 手里却握着**裸对象**引用，系统中出现**两套 A**。
- 提前暴露**代理本身**，确保“所有人拿到的是同一份引用”。

> 这正是 SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference 存在的意义：**让诸如 AbstractAutoProxyCreator 能在半成品阶段就决定是否需要代理，并把代理作为 early reference 暴露**。





# **关键代码路径（逻辑化伪码）**

```java
// DefaultSingletonBeanRegistry#getSingleton(name, allowEarlyReference)
if ((bean = singletonObjects.get(name)) != null) return bean;
if (isCurrentlyInCreation(name)) {
    if ((early = earlySingletonObjects.get(name)) != null) return early;
    if (allowEarlyReference) {
        ObjectFactory<?> factory = singletonFactories.get(name);
        if (factory != null) {
            Object earlyRef = factory.getObject(); // 触发 getEarlyBeanReference → 可创建代理
            earlySingletonObjects.put(name, earlyRef);
            singletonFactories.remove(name);
            return earlyRef;
        }
    }
}
return null;
```

在 doCreateBean 里，创建早期工厂的时机（要点）：

```java
// 1. 仅实例化，不做注入
Object beanInstance = createBeanInstance();

boolean earlyExposure = mbd.isSingleton() && this.allowCircularReferences
        && isSingletonCurrentlyInCreation(beanName);
// 2. 将工厂（可产出早期引用）放入三级缓存
if (earlyExposure) {
    addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, beanInstance));
}

// 3. 开始属性注入（populateBean），必要时别的 Bean 会通过上面的工厂拿到 earlyRef
populateBean(beanName, mbd, bw);

// 4. 初始化完成后，移入一级缓存（若早期暴露的是代理，最终也会以同一代理对外）
Object exposedObject = initializeBean(beanName, bean); 
addSingleton(beanName, exposedObject);
```



# **哪些后处理器会“提前建代理”？**

- 实际上由 AbstractAutoProxyCreator（如 AnnotationAwareAspectJAutoProxyCreator）实现：

  在 getEarlyBeanReference 中，会决定是否为该 bean **提早**创建代理（JDK/CGLIB），并返回这个代理作为 early reference。

- 这样，即便 bean 仍在创建中，**依赖它的其它 Bean 也能拿到“可用的代理”**。





# **能解决哪些循环，解决不了哪些？**

✅ 能解决：

- **单例**作用域
- **字段 / setter 注入**的循环依赖（A 有 B；B 有 A）
- 需要 AOP 的场景（保证注入点拿到的就是代理）



❌ 不能解决：

- **构造器注入**的循环依赖（实例都还没“裸出来”，没法放进 3 级缓存）
- **原型（prototype）**的循环依赖（没有全局缓存）
- 显式 @DependsOn 强制顺序导致死环
- 被明确关闭的场景：allowCircularReferences=false





# **小结成一张“时序图”**

```
create A
 ├─ 实例化 A（仅构造）
 ├─ 三级缓存登记 A 的 ObjectFactory（可产出 early-ref，可能是代理）
 └─ 注入属性：需要 B → getBean(B)
        create B
        ├─ 实例化 B（仅构造）
        ├─ 三级缓存登记 B 的 ObjectFactory
        └─ 注入属性：需要 A → getBean(A)
               ├─ 发现 A 正在创建 → 尝试 early-ref
               ├─ 用 A 的 ObjectFactory 产出 early-ref（可能已是代理）
               └─ 二级缓存存 A 的 early-ref，返回给 B 注入
        └─ B 初始化完成 → 一级缓存存 B
 └─ 回来给 A 完成剩余注入/初始化 → 一级缓存存 A（与 early-ref 保持一致的代理）
```



# **与常见注解/问题的关系**

- @Transactional/@Async/@Validated 等需要代理的注解：

  通过**提前暴露代理**确保**循环依赖中的所有引用都是代理**，避免“有处生效、有处失效”。

- 自调用（self-invocation）问题：

  即使提前暴露代理也**无法**解决自调用（在同一个实例内部直接调用方法绕过代理）；那是另一个经典问题，需要**从外部通过代理调用**或拆分成独立 bean。

- @Lazy：

  某些循环可以通过 @Lazy 延迟注入来规避，但与 3 级缓存机制属于两种思路。





# **一句话结论**

- **三级缓存**存在的目的：在“单例 + 字段/Setter 注入”的循环依赖里，**先交付一个“可用的早期引用”**给依赖方，避免死锁。
- **必须提前暴露“代理”而不是“裸对象”**：确保系统中**所有注入点拿到的是同一个代理**，从而统一地应用切面与语义，不出现“有的地方被增强，有的地方没增强”的不一致。





# 为什么需要三级缓存（明明两级就能解决问题）

很好，这个问题问到点子上了：**为什么不是两级缓存，而是非要 singletonFactories → earlySingletonObjects → singletonObjects 三级？**



核心答案：**因为“早期引用”不总是需要、且有时必须是“代理而不是原始对象”。只有用“工厂（第三级）→按需产出→缓存早期引用（第二级）”这一跳，才能**

1. **只在真的发生依赖环时才创建 early-ref**（避免无谓工作/内存），
2. **在创建 early-ref 的瞬间就能决定是否需要“提前代理”**，并把“代理”而非“裸对象”放出去，
3. **保证所有拿到的引用一致**（避免一部分拿到裸对象、一部分拿到代理），
4. **维持生命周期顺序与并发安全**（只产出一次、不会被过早暴露）。

下面把“两级设计为何不行、三级设计如何解决”逐条说清。



## **如果只有两级缓存，会出现什么问题？**

设想你说的“两级版”：

- **一级**：singletonObjects（成品）
- **二级**：earlySingletonObjects（一实例化完就把“早期对象”塞进来）

听上去简单，但立刻踩坑：



### **问题 1：**会过早、过多地创建 early-ref（甚至代理）

- 现实中**大多数 Bean 并没有循环依赖**。
- 如果实例化完就塞进二级，要么：
  - 塞**原始对象**：一旦后面真的发生环且该 Bean 需要 AOP，**你已经把“裸对象”发出去了**，之后再包代理就**出现引用分裂**（部分地方拿到裸对象，其他地方拿到代理）；
  - 或者一开始就塞**代理**：那就把**所有 Bean**都“提前代理”了——**成本高**、**语义被改变**（本该只在 postProcessAfterInitialization 阶段才决定是否代理）。

**结论**：需要一个**“只在有人真的来要 early-ref 时才产生它”的机制**，而不是一上来就放一个“早期实体”。这就是**第三级：singletonFactories**的作用——**延迟决定、按需产出**。





### **问题 2：**无法保证“优先发出去的是代理而不是裸对象”

- AOP 自动代理器（AbstractAutoProxyCreator）是在 **early-ref 被请求的那个时刻** 通过

  SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference

  **决定是否要“提前”创建代理**。

- 若你在实例化后就把**裸对象**塞进二级，**当 B 第一次来要 A** 时已经**晚了**：B 会拿到裸对象；等 A 最终完成时再包代理，**全局出现两份不同引用**。

- 反之，若你为了避免分裂，一上来就把**代理**塞进二级，那就又回到“为所有 Bean 都提前建代理”的问题。

**结论**：需要一个**“工厂占位”**，等真正需要 early-ref 的那一刻，**一次性产出“正确形态”的对象（通常是代理）**并缓存，这正是第三级的职责。





### **问题 3：**生命周期/回调顺序会被打乱

- Spring 的顺序是：**实例化 →（登记工厂）→ 属性注入 → 初始化回调 → 成品入一级**。
- 过早把“早期对象”固化到二级，会让 **BeanPostProcessor 的一些时点钩子**（尤其与类型预测、合并定义、候选切面匹配相关）**失去发挥空间**，或在还没走到该阶段时就把“不可回收的引用”发出去了，破坏既有的生命周期契约。





### **问题 4：**并发与幂等

- 在循环依赖并发场景下，**可能有多个线程几乎同时来要 A 的 early-ref**。
- 通过**第三级工厂 → 原子地产出一次 → 放入第二级**，能够**确保只创建一个 canonical 的 early-ref**；纯两级方案容易出现**重复创建/竞态**或需要更复杂的同步。





## **三级各自扮演的角色（为什么恰好是这样分工）**

- **第 3 级：****singletonFactories****（ObjectFactory）**

  只放一个**轻量的“供应器”**，并不提前创建对象；当且仅当有循环依赖导致“需要 early-ref”时才**调用工厂**：

  - 在这个调用点，SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference 有机会**判断并提前创建代理**；
  - 产出的 **就是“最终要对外一致使用”的那个引用**（通常是代理）。

  

- **第 2 级：****earlySingletonObjects****（early-ref 池）**

  一旦工厂**产出了** early-ref，就**落盘到这里**，供后续所有注入者重复使用，**避免再次调用工厂**；

  ——它保证：**一旦早期引用确定，就稳定、唯一、可复用**。

- **第 1 级：****singletonObjects****（成品池）**

  初始化彻底完成后，才放入这里；如果之前暴露的是代理，**成品阶段也会保持同一引用**，不产生分裂。

> 这三层配合的关键点：

> **“是否需要早期引用”** 与 **“早期引用的形态（代理/原始）”** 两个决策都被**推迟到真正有需要的那个瞬间**，并且一旦决策，就**用二级缓存把结果固定下来**。





## **小结（一句话版）**

- **两级**做不到：既**延迟到“有需要时才创建 early-ref”**，又**确保“创建时就能提前代理并全局唯一”**。

- **第三级** **singletonFactories** 提供了这个“**按需产出 + 提前代理**”的挂点；

- **第二级** **earlySingletonObjects** 则把已产出的 early-ref **固化与复用**；

- **第一级** **singletonObjects** 仍是最终成品池。

  三者合起来，既满足性能/内存，又保证生命周期与 AOP 语义一致性，还处理了并发与幂等。

如果你愿意，我可以把 doCreateBean() 中 addSingletonFactory(...) 的精确时点、以及 getSingleton(..., allowEarlyReference=true) 落到二级缓存的那几行源码走读一遍，并标注“为什么必须在**实例化后、填充属性前**登记工厂”。





# 如果没有循环依赖那三级缓存如何工作

**没有循环依赖时，二级缓存不会用到；三级缓存通常会“登记但不触发”；最终对象直接进一级缓存。**

```
1) 实例化 bean（createBeanInstance）
   └─（若允许循环依赖）addSingletonFactory(bean) → 把“产生早期引用”的工厂先放到【三级缓存】
      ※ 这里只是“占位”，并没有产出 early reference

2) 属性注入 → Aware → @PostConstruct/afterPropertiesSet → init-method

3) 初始化后置（postProcessAfterInitialization）
   └─ 需要 AOP 时在此“一次性创建最终代理”

4) addSingleton(bean, exposedObj)
   └─ 把（可能是代理的）成品放入【一级缓存】
   └─ 清理：将该 bean 在【二级/三级】中的条目移除（如果有的话）
```

关键点：

- **二级缓存（earlySingletonObjects）只在“有人在我创建尚未完成时**来依赖我”才会被用到——也就是**出现循环依赖**时，三级里的 ObjectFactory 被调用产出 early reference，再转存到二级。**没有循环依赖，就没人来拿 early reference，二级始终为空。**
- **三级缓存（singletonFactories）在大多数单例创建时都会登记一个工厂，但绝大多数情况下不会被调用**；它只是为了“万一有人在我没初始化完就要我”时能给出早期引用（必要时还是代理）。**没有人来要，就不触发。**
- **最终对象不是“由三级缓存生成”的**：对象在 createBeanInstance 就已 new 出来，后续完成初始化；若没有循环依赖，**不会通过三级工厂走一遍**，而是直接在完成初始化后放入一级缓存。

因此可以把没有循环依赖的路径理解为：**“1级直达”，2级未用、3级占位但未触发。**