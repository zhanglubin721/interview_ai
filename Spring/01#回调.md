# **业务常用的 10 个回调（什么时候用、适合干嘛）**

1. **@PostConstruct**
   - **时机**：本 Bean 完成依赖注入之后、初始化之前（*仅保证本 Bean 的依赖已就绪，不保证别的单例都建好*）。
   - **用途**：读配置、建本地缓存、启动轻量资源。
   - **避免**：不要依赖“所有单例已创建”。
2. **InitializingBean#afterPropertiesSet() / 自定义 init-method**
   - **时机**：紧随 @PostConstruct 之后。
   - **用途**：与 @PostConstruct 类似；二选一即可，便于测试/接口隔离。
3. **BeanPostProcessor#postProcessBefore/AfterInitialization**
   - **时机**：所有 Bean 初始化前/后（对“别人的 Bean”生效）。
   - **用途**：切面式增强、统一包裹代理、校验/注册指标。
   - **注意**：是“横切点”，不是业务 Bean 自用的钩子。
4. **SmartInitializingSingleton#afterSingletonsInstantiated()**
   - **时机**：**所有单例**都创建完、所有 BeanPostProcessor 也跑完之后。
   - **用途**：**全局预热**（需要依赖“别的单例也已就绪”的场景），比如把多张表的字典加载进内存。
   - **对比**：比 @PostConstruct 更“晚”，适合确实要等全局就绪再做的事。
5. **ApplicationRunner / CommandLineRunner**（Spring Boot）
   - **时机**：ApplicationStartedEvent 之后、ApplicationReadyEvent 之前。
   - **用途**：应用启动一次性的任务（如预热大缓存、建索引、打印启动横幅）。
   - **对比**：比上面的 bean 钩子更靠近“应用层”。
6. **@EventListener(ApplicationReadyEvent.class)**（Spring Boot）
   - **时机**：**应用完全就绪**后（包括 Runner 执行完）。
   - **用途**：真·“对外就绪”后再触发的动作（如开始消费外部队列、对外发健康探针 OK）。
7. **@PreDestroy**
   - **时机**：容器关闭时、本 Bean 销毁前。
   - **用途**：释放资源、停止后台线程、flush 缓存。
8. **DisposableBean#destroy() / 自定义 destroy-method**
   - **时机**：紧随 @PreDestroy 之后。
   - **用途**：与 @PreDestroy 类似；二选一即可。
9. **SmartLifecycle#start()/stop()**
   - **时机**：ContextRefreshed 后按 phase 有序启动；关闭时反向 stop()。
   - **用途**：需要“可控启停顺序”的组件（比如先起注册中心客户端，再起业务订阅者）。
10. **ApplicationContextAware / EnvironmentAware**（以及一系列 *Aware）

- **时机**：属性填充后、初始化前。
- **用途**：拿到 ApplicationContext、Environment、ResourceLoader 等。

> **选哪个做“数据预热”？**

- > 只依赖本 Bean 注入 → 用 @PostConstruct / afterPropertiesSet。

- > 必须等“所有单例都准备好” → 用 SmartInitializingSingleton。

- > 与“应用启动阶段”绑定（一次性任务） → 用 ApplicationRunner / ApplicationReadyEvent。



# **单个 Bean 的完整生命周期（按执行顺序标号）**

> 下面是**默认单例 Bean**从“准备创建”到“销毁”的关键步骤；★ 为你最可能用到的钩子。

**创建阶段**

1. （可选）InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
2. **构造器/工厂方法实例化**
3. （可选）MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition
4. （可选）InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
5. **依赖注入/属性填充**（@Autowired 等）
6. ***Aware 回调**：BeanNameAware → BeanClassLoaderAware → BeanFactoryAware → … → ApplicationContextAware
7. **BeanPostProcessor#postProcessBeforeInitialization**
8. **★ @PostConstruct**
9. **★ InitializingBean#afterPropertiesSet() / init-method**
10. **BeanPostProcessor#postProcessAfterInitialization**（AOP 代理大多在此完成）

**单例全部完成后**

1. **★ SmartInitializingSingleton#afterSingletonsInstantiated()**（一次，所有单例准备就绪）

**容器刷新后（可选，组件类）**

1. **SmartLifecycle#start()**（按 phase 启动）

**销毁阶段**

1. DestructionAwareBeanPostProcessor#postProcessBeforeDestruction
2. **★ @PreDestroy**
3. **★ DisposableBean#destroy() / destroy-method**
4. SmartLifecycle#stop()（按 phase 停止）

> ⚠️ 这些步骤不是“只有一个函数”的固定集合，而是多个接口/注解形成的“可插拔点”。你用哪个，就会执行哪个。





# **容器级与 Spring Boot 启动阶段钩子（决定“更早/更晚”的事）**

**容器启动前后（比 Bean 更早）**

- BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry

  **时机**：**任何 Bean 实例化之前**。

  **用途**：动态注册 Bean 定义（如扫描、按条件注册）。

- BeanFactoryPostProcessor#postProcessBeanFactory

  **时机**：仍在 Bean 实例化之前。

  **用途**：修改 BeanDefinition、占位符替换、条件装配。

- ApplicationContextInitializer#initialize(ConfigurableApplicationContext)（Boot）

  **时机**：SpringApplication.run() 早期，refresh() 之前。

  **用途**：最早期的上下文定制（通常配合 spring.factories/META-INF/spring）。

**Spring Boot Application 事件流（了解即可）**

ApplicationStarting → EnvironmentPrepared → ContextInitialized → ApplicationPrepared →

ApplicationStarted → **（Runner 执行）** → ApplicationReady → Failed

- **Runner**：在 ApplicationStarted 与 ApplicationReady 之间。
- **ApplicationReady**：Runner 全部完成后，再广播；可认为“对外就绪”。





# **“Spring 一个类的生命周期中有多少这样的函数？”**

严格说**没有固定“多少个函数”的答案，因为钩子是由接口/注解能力**组成的，你“选择实现/标注了哪个”，生命周期里就会出现哪个。

但如果你问“**对一个普通单例 Bean**，常见、可数的生命周期回调有多少”，可以这样统计（不含极少用/内部类）：

- **创建前后/注入/初始化相关**：

  postProcessBeforeInstantiation、构造器、postProcessAfterInstantiation、属性填充、若干 *Aware、postProcessBeforeInitialization、@PostConstruct、afterPropertiesSet、init-method、postProcessAfterInitialization、afterSingletonsInstantiated（单例完成后）。

  → **约 10~12 个关键点**（你常用的其中 4~6 个）。

- **销毁相关**：

  postProcessBeforeDestruction、@PreDestroy、destroy()、destroy-method、SmartLifecycle#stop

  → **约 4~5 个关键点**（常用 2 个）。

- **容器/Boot 级**（全应用维度，非单个 Bean）：

  BeanDefinitionRegistryPostProcessor、BeanFactoryPostProcessor、ApplicationContextInitializer、Boot 的 Runner、ApplicationReadyEvent、各类 ApplicationEvent。

  → **5+ 个常见点**。

> 换句话说：**单个 Bean 的“常用生命周期钩子”你真正在业务里会用到的，大概 6～8 个足够**；剩下的是更底层或横切的扩展点。





## **实战建议（如何选钩子做“数据预热/资源管理”）**

- **预热依赖仅限于当前 Bean 的注入** → @PostConstruct / afterPropertiesSet。
- **预热需要“所有单例就绪/所有代理织入完成”** → SmartInitializingSingleton。
- **要把预热放在“应用启动一次性任务”** → ApplicationRunner 或 @EventListener(ApplicationReadyEvent.class)。
- **需要可控启停顺序** → SmartLifecycle（设置 getPhase() 编排顺序）。
- **清理资源** → @PreDestroy（优先）或 DisposableBean#destroy()。
- **做全局增强/审计** → BeanPostProcessor（改“别人”的 Bean）。
- **需要“在实例化任何 Bean 之前”动态注册/修改 Bean 定义** → BeanDefinitionRegistryPostProcessor / BeanFactoryPostProcessor。