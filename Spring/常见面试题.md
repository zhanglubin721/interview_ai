## Spring bean

### 生命周期：

**Spring Bean（以单例为例）在容器刷新时先被“实例化”（选构造器/工厂方法得到裸对象），随后做“依赖注入/属性赋值”，接着触发各类 Aware 回调（如 BeanNameAware/BeanFactoryAware），然后进入“初始化前置”——BeanPostProcessor#postProcessBeforeInitialization（此阶段会执行 @PostConstruct），再到“初始化”本身——InitializingBean#afterPropertiesSet 与自定义 init-method，紧接着“初始化后置”——BeanPostProcessor#postProcessAfterInitialization**（此步若命中切面会一次性创建最终代理）；完成后放入一级缓存供业务使用；当容器关闭时按顺序销毁：DestructionAwareBeanPostProcessor#postProcessBeforeDestruction（执行 @PreDestroy）→ DisposableBean#destroy → 自定义 destroy-method。补充：prototype 不自动执行销毁回调；所有单例就绪后还会触发 SmartInitializingSingleton#afterSingletonsInstantiated 用于“全局就绪后”的初始化收尾。



### spring如何解决循环依赖问题：

Spring 解决“单例 + 字段/Setter 注入”的循环依赖，靠 DefaultSingletonBeanRegistry 的**三级缓存**与**提前暴露早期引用（可能是代理）**：创建 A 时只先“实例化”（构造函数），随后把一个能按需产出 A 早期引用的 ObjectFactory 放进 **三级缓存 singletonFactories**，这一步尚未注入属性；接着给 A 注入属性时发现需要 B，于是去创建 B，B 在被实例化后也把自己的工厂放入三级缓存；当给 B 注入属性时又反过来需要 A，此时 getSingleton(A, allowEarlyReference=true) 发现一级、二级都没有，但**三级有工厂**，就调用工厂产出 **A 的 early reference** 并放入 **二级缓存 earlySingletonObjects**（同时从三级删除工厂）返回给 B 注入，B 因而得以完成初始化并进入 **一级缓存 singletonObjects**；随后回到 A，A 现在能从一级拿到 B，完成自身初始化并进入一级缓存。产出“早期引用”的瞬间会调用 SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference（例如 AbstractAutoProxyCreator），从而**在非常早的时刻就把 AOP 代理创建好并作为 early reference 暴露**，保证整个系统里“别人注入到的 A”与“最终对外暴露的 A”是**同一份引用（通常是代理）**，避免出现一部分代码拿到裸对象、一部分拿到代理的语义分裂；这一机制**只能**解“单例 + 非构造器注入”的环，**不能**解“构造器↔构造器”的环（实例都还没产出，放不进三级缓存）和 **prototype** 的环；若需要刻意打破构造器环，应改为在构造器参数上加 @Lazy 或使用 ObjectProvider/编程式事务等延迟解析手段；另外在 Spring Boot 2.6+ 默认关闭循环依赖（spring.main.allow-circular-references=false），不开启则直接报错。



### 动态代理：

拦截器集合

```java
[
  ExposeInvocationInterceptor.INSTANCE,    // Spring 内置
  TransactionInterceptor,                  // 来自 @Transactional
  MethodValidationInterceptor,             // 来自 @Validated
  AspectJAroundAdvice(@Around Loggable),   // 你的切面
  MethodBeforeAdviceInterceptor(@Before Loggable),
  AfterReturningAdviceInterceptor(@AfterReturning Loggable),
  AspectJAfterAdvice(@After Loggable)
]
```



生成代理类

```java
final class DynamicAdvisedInterceptor implements MethodInterceptor {
  private final AdvisedSupport advised; // 里头有目标对象、接口/类、Advisor列表、工厂等
  private transient Map<Method, List<Object>> methodCache; // 每个方法的链缓存（简化）

  @Override
  public Object intercept(Object proxy, Method method, Object[] args, MethodProxy mp) throws Throwable {
    // 1) 取/建 “本方法”的拦截器链（已排序、已适配）
    List<Object> chain =
        advised.getInterceptorsAndDynamicInterceptionAdvice(method, advised.getTargetClass());
    if (chain.isEmpty()) {
      // 没有增强：直调目标
      return mp.invoke(advised.getTargetSource().getTarget(), args);
    }
    // 2) 构建一次性的调用上下文，沿链执行
    MethodInvocation mi = new CglibMethodInvocation(proxy,
                                                    advised.getTargetSource().getTarget(),
                                                    method, args, chain, mp);
    return mi.proceed();
  }
}
```



代理类内部执行代理方法和目标方法的流程

```java
class ReflectiveMethodInvocation implements MethodInvocation {
  private final List<Object> interceptors;
  private int index = -1;

  public Object proceed() throws Throwable {
    if (index == interceptors.size() - 1) {
      return invokeJoinpoint(); // 真正调目标方法
    }
    Object next = interceptors.get(++index);
    if (next instanceof InterceptorAndDynamicMethodMatcher dm) {
      // 运行期匹配，不通过就跳过后续的这个拦截器
      if (!dm.methodMatcher.matches(method, targetClass, args)) {
        return proceed();
      }
      return ((MethodInterceptor) dm.interceptor).invoke(this);
    }
    return ((MethodInterceptor) next).invoke(this);
  }
}
```

Spring 的拦截器链就是“责任链 + 递归式展开”的控制流：

- 调用从第 0 个拦截器开始，proceed() 每次把索引 index 前移一位并**调用下一个拦截器的** **invoke()**；拦截器里通常又会再调用 proceed()，于是形成**洋葱式的递归入栈**。
- **终止条件（base case）**：当 index == interceptors.size() - 1（再没有下一个拦截器）时，执行 **invokeJoinpoint()** **调到目标方法**。
- 目标方法返回后，按调用栈**反向出栈**，依次执行各拦截器的 “after/commit/cleanup” 逻辑，所以你看到的是：

```
Tx.before → Validation.before → … → target
                             ← … → Validation.after → Tx.commit
```

- 两个补充：
  - 若某个拦截器**不调用** **proceed()**（例如鉴权失败直接抛异常/返回），链路会**短路**，后面的都不会执行。
  - 带**运行期匹配**的切点（如 args()）会在当前点判断不匹配则**跳过该拦截器**，继续 proceed()。

所以它的确“看起来像递归”，但本质是**有索引控制的责任链**；递归结束标志就是**没有更多拦截器可执行**。



### JDK、CGLIB：

| **维度**   | **JDK 动态代理**                                        | **CGLIB（子类代理）**                                        |
| ---------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 触发条件   | 目标 **实现了接口**（默认优先用 JDK）                   | 目标**没有接口**或强制 proxyTargetClass=true                 |
| 拦截范围   | **只能拦接口方法**（代理类只实现接口）                  | **类上的非 final 方法**（通过生成子类重写）                  |
| 限制       | 若业务通过 **类引用**调用非接口方法则拦不住             | **final 类/方法不能代理**；构造器会被调用                    |
| 强制方式   | @EnableAspectJAutoProxy(proxyTargetClass=false)（默认） | @EnableAspectJAutoProxy(proxyTargetClass=true) 或 spring.aop.proxy-target-class=true |
| 自调用问题 | 都存在：**同类内 this.xxx() 不走代理**                  |                                                              |
| 性能       | 现代 JDK 上两者差距很小，**按语义选**即可               |                                                              |



### Spring启动流程：

**Spring（Framework）启动流程（一句话版长段）：应用启动时创建 ApplicationContext 并执行 refresh() 主流程：先准备 Environment 与占位符源，加载与解析 Bean 定义（BeanDefinition，包括 XML/注解；ConfigurationClassPostProcessor 解析 @Configuration/@ComponentScan/@Import/@Bean 并把新定义注册进工厂）；随后执行 BeanFactoryPostProcessor/BeanDefinitionRegistryPostProcessor 完成对工厂与定义的改写；再注册并排序所有 BeanPostProcessor（AOP 的 AutoProxyCreator 等此时就位）；接着按依赖拓扑实例化非懒加载单例**：先“仅实例化”→（允许循环依赖则把 ObjectFactory 放入三级缓存）→ 属性注入与校验 → *Aware* 回调 → @PostConstruct/afterPropertiesSet/init-method → **初始化后置**（若命中切面在此**一次性创建最终代理**）→ 放入一级缓存；全部单例创建完触发 SmartInitializingSingleton#afterSingletonsInstantiated 与 ContextRefreshedEvent，启动 Lifecycle/SmartLifecycle Bean（如调度器等），最后注册 JVM 关闭钩子以便优雅销毁（@PreDestroy → destroy()），至此容器就绪。



### Spring Boot启动流程：

**Spring Boot 启动流程（一句话版长段）：**SpringApplication.run(...) 驱动启动：构造 SpringApplication 后发布早期事件并准备日志，推断应用类型（Servlet/WebFlux/none）与 ApplicationContext 实现，**准备环境**（解析命令行与 application*.properties|yaml、Profile、ConfigData；绑定到 Environment），打印 Banner，创建并配置 ApplicationContext，应用 ApplicationContextInitializer，注册 ApplicationListener，把 @SpringBootApplication 的主配置类作为源；随后通过 **@EnableAutoConfiguration** 的导入选择器加载 **自动配置**（Boot 3 使用 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 清单），结合 @ConditionalOnClass/@ConditionalOnMissingBean/@ConditionalOnProperty 等条件选择性注册大量 BeanDefinition，并执行 refresh()（即上面 Spring 的整套生命周期）；若是 Web 应用，自动配置创建嵌入式容器（如 Tomcat/Jetty/Netty）并完成端口监听；ApplicationStartedEvent 与 ApplicationReadyEvent 依次发布，最后按顺序运行 ApplicationRunner/CommandLineRunner；整个过程中还有失败分析器与外部化配置绑定（@ConfigurationProperties）等机制加持，因此可以“零 XML、约定优于配置”地把环境、自动配置、服务器与业务 Bean 一起拉起。



## **@Transactional**

### 常用参数：

```java
@Transactional(
  propagation = Propagation.REQUIRED,     // 传播行为
  isolation   = Isolation.READ_COMMITTED, // 隔离级别（默认随数据库；MySQL InnoDB 默认 REPEATABLE_READ）
  timeout     = 30,                       // 秒；超时自动回滚（平台驱动）
  readOnly    = true,                     // 只读优化：对 JPA/Hibernate 设 flush 策略；DB 侧多为 hint
  rollbackFor = { Exception.class },      // 默认只对 RuntimeException/Error 回滚；Checked 需显式声明
  noRollbackFor = { SomeBizException.class }, // 避免某些异常触发回滚
  transactionManager = "txManager"        // 多数据源时指定
)
```



### 传播行为：

| **传播行为**     | **外层已存在事务？** | **Spring 行为**                     | **是否挂起外层** | **典型场景**                                    |
| ---------------- | -------------------- | ----------------------------------- | ---------------- | ----------------------------------------------- |
| REQUIRED（默认） | 有                   | **加入**外层                        | 否               | 最常用；同成败、同回滚                          |
| REQUIRES_NEW     | 有                   | **挂起**外层，**新开**事务          | 是               | 子步骤必须独立提交/回滚（如记审计日志、发消息） |
| SUPPORTS         | 有                   | 加入外层                            | 否               | “能事务就进，不强求”；查询                      |
| SUPPORTS         | 无                   | 非事务执行                          | 否               |                                                 |
| NOT_SUPPORTED    | 有                   | **挂起**外层，非事务执行            | 是               | 绝不想被事务影响（大查询、调用外部服务）        |
| MANDATORY        | 有                   | 加入外层                            | 否               | 必须在事务内；没有就**抛异常**                  |
| MANDATORY        | 无                   | 抛 IllegalTransactionStateException | —                |                                                 |
| NEVER            | 有                   | 抛 IllegalTransactionStateException | —                | 禁止在事务中运行                                |
| NEVER            | 无                   | 非事务执行                          | 否               |                                                 |
| NESTED*          | 有                   | 外层内**开保存点**                  | 否               | 批处理：子步骤失败只回滚到保存点、外层可继续    |
| NESTED           | 无                   | 等同 REQUIRED                       | 否               |                                                 |



### 主子方法传播行为实际使用：

```java
@Service
@RequiredArgsConstructor
public class ParentService {
    private final ChildTxService child;

    @Transactional // 主事务
    public void callerUseSameTx() {
        child.workSameTx();      // 加入主事务（REQUIRED）
    }

    @Transactional // 主事务
    public void callerUseNewTx() {
        child.workNewTx();       // 挂起主事务，另开事务（REQUIRES_NEW）
        child.workNonTx();       // 挂起主事务，非事务执行（NOT_SUPPORTED）
    }
}

@Service
public class ChildTxService {

    // 与调用方同一个事务（有则加入，无则新建）
    @Transactional(propagation = Propagation.REQUIRED)
    public void workSameTx() { /* .内部调用真正的 work 方法.. */ }

    // 无论外面有没有事务，这里都新开并独立提交/回滚
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void workNewTx() { /* .内部调用真正的 work 方法.. */ }

    // 强制脱离事务（挂起外层，以非事务方式执行）
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void workNonTx() { /* .内部调用真正的 work 方法.. */ }
}
```

如果需要同一个子方法在不同的主方法调用时使用不同的传播行为策略，可以借鉴上面的ChildTxService，这叫**策略模式**



### 事务注解不生效：

1. 自调用不经过代理（this）；

2. 非 public

- **JDK 动态代理**：只代理**接口方法**（接口方法必然是 public）。非 public 根本不在代理暴露的签名里，**不可能被拦截**。
- **CGLIB 代理**：虽然技术上能覆写并拦截**非** **final** **的受保护/包级可见方法**，但**事务只在“经由代理的外部调用”才生效**。而非 public 方法通常**不会**被外部代码直接调；同类内部 this.xxx() 的“自调用”又**绕过代理**，因此**依然不生效**。private/final 方法更是**无法拦截**。

3. 异常被捕获吞掉；
3. rollbackFor 未命中；
3. 多数据源事务管理器错配；
3. 只读误用；
3.  代理没生效（放错位置/final）；8. 异步线程执行

