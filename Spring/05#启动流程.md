## Spring 启动流程

```java
(你 new ApplicationContext 或 Spring 内部创建)
        │
        ▼
[1] context.refresh()
    ├─ 1.1 准备上下文：设定 id、时区、加载器等基础对象
    │
    ├─ 1.2 准备 Environment（环境）
    │       - 收集“配置属性”：系统环境变量、JVM -D、配置文件占位符等
    │       - 处理激活的 profile（比如 dev/prod）
    │
    ├─ 1.3 加载 Bean 定义（BeanDefinition）
    │       - 扫描 @Configuration/@Component/@Bean/@Import
    │       - 或读取 XML/其它来源
    │
    ├─ 1.4 工厂级改造（*BeanFactoryPostProcessor）
    │       - 允许在“实例化 Bean 之前”批量修改/新增 Bean 定义
    │       - 典型：解析 @Configuration，把 @Bean 方法变成 BeanDefinition
    │
    ├─ 1.5 注册 BeanPostProcessor（Bean 级拦截器）
    │       - 如：@Autowired 处理器、AOP 自动代理器、@PostConstruct 处理器
    │
    ├─ 1.6 初始化消息源/事件广播器/监听器
    │
    ├─ 1.7 实例化非懒加载的单例（preInstantiateSingletons）
    │       对每个 Bean 依次执行：
    │       a) 实例化（选构造器 → new）
    │          - 允许循环依赖：把“早期引用工厂”放进三级缓存
    │       b) 依赖注入（@Autowired/@Value 等）
    │       c) Aware 回调（BeanNameAware/BeanFactoryAware…）
    │       d) 初始化前置（postProcessBeforeInitialization）
    │          - 执行 @PostConstruct
    │       e) 初始化方法（afterPropertiesSet / init-method）
    │       f) 初始化后置（postProcessAfterInitialization）
    │          - 命中切面时：通过 ProxyFactory “一次性”创建最终代理
    │       g) 放入单例池（一级缓存），可被别人使用
    │
    ├─ 1.8 调用 SmartInitializingSingleton（所有单例就绪后的收尾）
    │
    ├─ 1.9 发布 ContextRefreshedEvent（容器已就绪）
    │
    └─ 1.10 注册 JVM 关闭钩子（优雅停机用）
            - 关闭时：@PreDestroy → DisposableBean#destroy → destroy-method
```

> 小词条速记：

- > **Environment**：一袋子“配置属性 + 激活的 profile”（dev/prod 等），供 @Value 等取值。

- > **BeanDefinition**：Bean 的蓝图（类型、作用域、依赖…），还没 new 出对象。

- > **BeanPostProcessor**：在“初始化前/后”插入逻辑的钩子；AOP/@Autowired/@PostConstruct 都靠它。





## Spring Boot启动流程

```java
SpringApplication.run(MainClass.class, args)
        │
        ▼
[1] 构造 SpringApplication
    - 推断应用类型（Servlet/WebFlux/None）
    - 准备日志、监听器、Banner
        │
        ▼
[2] 准备 Environment（外部化配置）
    - 解析命令行、application.yml/properties、环境变量
    - 处理 profile（如 spring.profiles.active=prod）
    - 把属性绑定到 Environment
        │
        ▼
[3] 创建 ApplicationContext（按应用类型）
    - Servlet：AnnotationConfigServletWebServerApplicationContext
    - 非 Web：AnnotationConfigApplicationContext
        │
        ▼
[4] 应用 Initializers / 注册 Listeners
    - 提前对 Context 做一次定制（如属性绑定、验证）
        │
        ▼
[5] 注册主配置类（@SpringBootApplication）
    - 把 MainClass 作为配置源放进 Context
        │
        ▼
[6] 处理自动配置（EnableAutoConfiguration）
    - 读取 AutoConfiguration 列表（Boot 3：imports 清单）
    - 基于条件注解 @ConditionalOnClass/@OnMissingBean/@OnProperty
      选择性注册“各种默认组件”的 BeanDefinition（数据源、JPA、MVC…）
        │
        ▼
[7] 调用 context.refresh()  ←（进入“Spring 标准启动流程”，见上图）
    - 加载/改造 Bean 定义、注册 BPP、实例化单例、创建 AOP 代理…
        │
        ▼
[8] 若是 Web 应用：启动嵌入式服务器
    - 创建 Tomcat/Jetty/Undertow 实例并监听端口
    - 注册 DispatcherServlet/Filter/拦截器/静态资源映射等
        │
        ▼
[9] 发布应用事件 & Runner
    - ApplicationStartedEvent → ApplicationReadyEvent
    - 依次执行 ApplicationRunner / CommandLineRunner
        │
        ▼
[10] 应用已就绪（开始对外提供服务）
    - 关闭时同样走优雅停机：触发销毁回调、停 Web 容器
```

> 你日常“写了个 @Service 然后启动被调用”的背后：

> Boot 替你**拼好配置（Environment）**、**按条件装配默认组件（自动配置）**、**创建 Web 服务器**，再进入**标准的 Spring refresh()** 完成 Bean 的实例化、依赖注入和 AOP 代理。你写的 @Service 最终在 **[7] 实例化单例** 那一步被创建并可被 Controller/其它 Bean 注入调用。





## Controller 接口映射

```java
客户端 → TCP:server.port
   │
   ▼
[Tomcat NIO 监听端口]
  ├─ Acceptor 接受连接，交给 Poller
  └─ Http11Processor 解析 HTTP 报文 → 生成 CoyoteRequest/CoyoteResponse
   │
   ▼
[Servlet 容器适配层]
  └─ CoyoteAdapter.service(...) 把请求转交给当前 WebApp 的 Filter/Servlet 链
   │
   ▼
[Filter 链（可有可无，多数由 Boot 自动装配）]
  ├─ Spring Security 的 FilterChainProxy（鉴权/鉴别）
  ├─ HiddenHttpMethodFilter / CharacterEncodingFilter / CorsFilter / 压缩等
  └─ DelegatingFilterProxy → 交给 Spring 容器里的过滤器
   │
   ▼
[DispatcherServlet]  ← Boot 注册的核心前端控制器（url-pattern 通常是 "/"）
  doDispatch():
    1) getHandler(request)  ← 逐个询问 HandlerMapping
       └─ RequestMappingHandlerMapping 基于启动时建立的映射表
          （类/方法上的 @RequestMapping/@GetMapping 等：
           路径、HTTP 方法、consumes/produces、params、headers…）
          → 匹配出 HandlerMethod（= 你的 controller 方法）+ 拦截器列表
    2) getHandlerAdapter(handler) → RequestMappingHandlerAdapter
    3) 执行拦截器 preHandle()（HandlerInterceptor）
    4) 调用控制器方法：
       ├─ 解析入参（HandlerMethodArgumentResolver）：
       │    @PathVariable, @RequestParam, @RequestHeader, @CookieValue,
       │    @RequestBody(→ HttpMessageConverter/Jackson), Servlet API 对象等
       ├─ 数据绑定/JSR-303 校验（@Valid/@Validated, BindingResult, @InitBinder）
       └─ 反射调用你的方法
    5) 处理返回值（HandlerMethodReturnValueHandler）：
       ├─ @ResponseBody/ResponseEntity → HttpMessageConverter 写出 JSON/文本/二进制
       └─ 或视图解析（ViewResolver + ModelAndView 渲染模板）
    6) 执行拦截器 postHandle()/afterCompletion()
   │
   ▼
[写回响应]
  └─ Tomcat 把响应写入 socket → 客户端收到
```

小贴士

- **映射表什么时候建好的？** 应用启动时，RequestMappingHandlerMapping 扫描 @Controller/@RestController 与 @RequestMapping，生成 RequestMappingInfo → HandlerMethod 的路由表并排序（路径模式、HTTP 方法、consumes/produces 等综合匹配）。
- **谁先谁后？** 静态资源、@Controller、@RestController 的匹配有优先级；拦截器的 preHandle/postHandle 会包裹在控制器前后。
- **常见变化**：换 Jetty/Undertow 只是“端口监听/协议解析”那一小段不同；走 WebFlux 则是 Netty + Reactor 的 Handler 链，但到控制器的“参数解析/返回值写出”概念相同。
- **异步**：控制器返回 Callable/DeferredResult/WebAsyncTask 时，DispatcherServlet 会挂起请求，业务在线程池跑完后再异步调回进行“渲染/写回”。



简明版答案（直击你关心的点）：





## HandlerMapping

以 RequestMappingHandlerMapping 为例，它用一个内部注册表 MappingRegistry 维护**“请求条件 → 控制器方法”**的对应关系，核心几张表（伪代码）：

```java
mappingLookup: Map<RequestMappingInfo, HandlerMethod>
    // 主索引：一个 RequestMappingInfo（路径/方法/consumes/produces/params/headers 等条件）
    // 指向一个 HandlerMethod（= beanName + Method 反射对象）

urlLookup: MultiValueMap<String, RequestMappingInfo>
    // 辅助索引：对“**无通配符、无路径变量**的直达路径”建立快速表
    // 如 "/users" → [RMI#1, RMI#2 ...]
    // 带 {id} 或 * 的不是直达路径，不进这张表

nameLookup: Map<String, HandlerMethod>
    // 可选：按 @RequestMapping(name="...") 或基于规则命名的方法名索引

corsLookup: Map<Object, CorsConfiguration>
    // CORS 相关（有则配）
```

> RequestMappingInfo 自身包含多种 **Condition**：

> patterns（一组路径模式） + methods（GET/POST…） + params/headers/consumes/produces 等，匹配时会综合判定并挑出“最佳匹配”。





**一个方法写了多个 URL（path/values数组）会怎样？**

```
@GetMapping({"/users/{id}", "/u/{id}"})
public User get(@PathVariable Long id) { ... }
```

- 启动时只**注册一条** RequestMappingInfo，其中 patterns = { "/users/{id}", "/u/{id}" }。

- 这条 RequestMappingInfo 与你的 HandlerMethod 一起放进 mappingLookup。

- 对于**没有通配符/变量**的模式（比如你再加一个 "/users"），会额外把该直达路径挂到 urlLookup 里做**快速精确匹配**；而 "/users/{id}"、"/u/{id}" 这种带变量的走**模式匹配**流程。

- 请求进来时，DispatcherServlet 调 getHandler()：

  1. 先用 urlLookup 做**精确匹配**（命中就只比对这几个 RMI）；
  2. 命不中再对所有候选 RequestMappingInfo 做**路径模式匹配**；
  3. 再按 HTTP 方法、consumes/produces、params/headers 等**逐项过滤**；
  4. 多个候选时用比较器选“**最具体**、约束最多”的那个；
  5. 得到 HandlerMethod，并解析 @PathVariable 等参数后调用你的方法。

  

**你可以这样理解存储结构**

```
RequestMappingInfo {
  patterns: {" /users/{id}", "/u/{id}" }   // 多个 URL 共指向同一方法
  methods:  {GET}
  consumes/produces/params/headers: 条件集合
}

HandlerMethod {
  bean: "userController"
  method: UserController#get(Long)
}
```

> 关键点：**多个 URL ≠ 多个方法**。是一条 RequestMappingInfo 里装了**多个 path 模式**，它们都映射到**同一个** HandlerMethod。