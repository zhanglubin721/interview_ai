# **1）结论先讲：一个 bean → 一个最终代理**

在 Spring AOP 的**自动代理**路径里（如 AnnotationAwareAspectJAutoProxyCreator、InfrastructureAdvisorAutoProxyCreator 等），“需要被增强”的目标 bean 会在创建时被 **一次性** 用 ProxyFactory 包装出 **一个代理对象**。

所有命中的切面/拦截器（Advisor）都会被**统一收集、排序**后，**一次 add 到 ProxyFactory**，得到**单个** JDK/CGLIB 代理。不是多轮包裹、不是代理套代理。





# **2）关键流水线（精炼版）**

以 AbstractAutoProxyCreator 为主线（省略细枝末节）：

```
createBean → （实例化）
  ↳ postProcessBeforeInstantiation?（可选，通常跳过）
  ↳ 实例化完成
  ↳ populateBean（属性注入）
  ↳ postProcessAfterInitialization(bean) {
        // 这里进入自动代理
        wrapIfNecessary(bean, beanName) {
            // 1. 找出候选 Advisor（切点来自 @Aspect、@Transactional、@Validated、@Async 等）
            List<Advisor> cands = findCandidateAdvisors();
            // 2. 过滤出对该 bean “可应用”的
            List<Advisor> eligible = findAdvisorsThatCanApply(cands, beanClass);
            if (eligible 非空) {
                // 3. 排序（Ordered/@Order/PriorityOrdered + 内置拦截器）
                sortAdvisors(eligible);
                // 4. 创建单个 Proxy：ProxyFactory pf = new ProxyFactory()
                //    - 选择 JDK 或 CGLIB
                //    - setTargetSource / setInterfaces / setProxyTargetClass
                //    - addAdvisors(eligible)  ← 一次性全部加上
                Object proxy = createProxy(pf);
                return proxy;  // 只返回“一个代理”
            }
            return bean; // 不需要增强，原样返回
        }
    }
```

注意：如果出现**循环依赖提前曝光**，getEarlyBeanReference 也会走 wrapIfNecessary，**提前**造出同一个最终代理，后续阶段会避免再包一次（见第 5 节）。





# **3）**ProxyFactory**如何把“多个 Advisor”变成“一条调用链”**

- ProxyFactory 内部持有 AdvisedSupport，保存目标信息与 Advisor 列表。
- 生成代理（JDK 或 CGLIB）时，会把每个 Advisor 通过 AdvisorAdapterRegistry 适配成 **MethodInterceptor**（例如 @Around 本身就是 MethodInterceptor；@Before/@AfterReturning/@Throws 会被适配成对应拦截器）。
- 运行期，每次方法调用会进入 ReflectiveMethodInvocation#proceed()，按**已排序**的拦截器列表**前进/回退**形成“洋葱”结构：

```
interceptor[0].invoke(
  -> interceptor[1].invoke(
     -> ...
       -> target.method(...)
     <- ...
   ) 
)
```

- 如果某些 Pointcut 有**运行期匹配**，会以 InterceptorAndDynamicMethodMatcher 的方式包裹，调用前再做一次 matches() 决定是否放行该拦截器。





# **4）Advisor 的“收集 & 排序”要点**

- **来源**：

  - @Aspect 类里的各条 advice → 拆成多个 Advisor；
  - 基础设施类：事务（BeanFactoryTransactionAttributeSourceAdvisor）、异步（AsyncAnnotationAdvisor）、方法校验（MethodValidationPostProcessor）等；

  

- **可应用性**：findAdvisorsThatCanApply 先看 ClassFilter 再看 MethodMatcher；

- **排序**：AnnotationAwareOrderComparator，遵循 PriorityOrdered → Ordered/@Order → 默认；同类型 advices 在同一 Aspect 中也会有固定顺序（Spring 保证“同一 aspect 内部的 advice 顺序稳定”，并与“不同切面之间的全局次序”叠加）。





# **5）为什么不会“多层代理”？**

Spring 的自动代理器专门做了**防双重包装**处理：

- **已代理检查**：在 wrapIfNecessary 里，若 bean 已是 AOP 代理（AopUtils.isAopProxy(bean)），默认**不会**再包一层。

- **早期代理去重**：为解决循环依赖时的“提前暴露”，AbstractAutoProxyCreator 维护了 earlyProxyReferences/advisedBeans 等集合：

  - getEarlyBeanReference 若已为该 bean 生成过代理，会把它登记；
  - postProcessAfterInitialization 再次判断若是“早期已代理”的 bean，就**直接返回原对象**，从而避免**第二次 wrap**。

  

- **统一出口**：无论是正常阶段还是“提前曝光”阶段，最终都走同一套 wrapIfNecessary → ProxyFactory → addAdvisors(全量)，所以**只会有一个最终代理**。

> 例外：如果你**手工**再用 ProxyFactoryBean 或别的 BPP 自己包一层，那当然可以人为制造“套娃”；但 Spring **内建自动代理链**不会这么做。





# **6）JDK vs CGLIB 的一次成型**

- 如果目标类**有接口**且未强制 proxyTargetClass=true，默认用 **JDK 动态代理**；否则用 **CGLIB**。
- 这仅仅决定**代理的实现方式**，与“是否一层代理”无关——两者都把**所有 Advisor 一次性**放进来，生成**一个**代理对象。





# **7）小样例（程序化演示“一次成型”）**

```
// 伪代码：把多个 Advisor 一次加入，得到一个代理
ProxyFactory pf = new ProxyFactory();
pf.setTarget(myTarget);
pf.setProxyTargetClass(true); // 或根据接口改用 JDK

pf.addAdvisor(txAdvisor);      // 事务
pf.addAdvisor(loggingAdvisor); // 日志
pf.addAdvisor(validateAdvisor);// 校验
// 甚至还有 ExposeInvocationInterceptor 等基础设施插队

MyService proxy = (MyService) pf.getProxy();
// proxy 是“唯一的”代理，调用时会按顺序经过三段拦截，再到目标方法
```



# **8）执行顺序与常见组合**

- 一般期望：**外层**是“横切契约”更强的（如事务），再到日志/性能，再到参数校验，最后到目标；
- 通过 @Order / Ordered 控制 Advisor 顺序，即可改变**链路先后**；**一旦排序确定**，链路在**单个代理里**稳定执行。







## **总结**

- Spring AOP 的自动代理机制会为“需要增强”的 bean **只创建一个最终代理**。
- 所有命中的 Advisor 在创建代理时由 ProxyFactory **一次性收集/排序/安装**到同一个代理对象上；
- 方法调用时通过 ReflectiveMethodInvocation 在**单条拦截链**里依次生效；
- 借助“已代理判断 + 早期代理去重”，**避免二次 wrap**，因此不会出现“嵌套多层代理”的套娃现象。





不是“生成很多层套娃代码”，而是**生成一个代理类 + 一条拦截器链**。调用时沿着链“像洋葱一样”前进/回退；看起来像层层嵌套，但那是**运行时控制流**，不是把类一层层再包一层。





## **1) JDK 动态代理时长什么样**

JDK 代理会生成一个 Proxy 子类，所有接口方法都转发给一个 InvocationHandler（Spring 的就是 JdkDynamicAopProxy）：

```
// 伪代码：JDK 代理
final class $Proxy123 extends Proxy implements MyService {
  private final InvocationHandler h; // = JdkDynamicAopProxy

  public Result doWork(Arg a) {
    // 代理方法本身很薄，只做一次转发
    return (Result) h.invoke(this, MyService.class.getMethod("doWork", Arg.class), new Object[]{a});
  }
}
```

JdkDynamicAopProxy.invoke(...) 做两件事：

1. **为当前方法挑 Advisor → 适配成 MethodInterceptor 列表**（按顺序排好，可能包含“运行期匹配”的动态切点包装）。
2. 用 ReflectiveMethodInvocation 执行这条链：

```
Object invoke(...) {
  List<Object> chain = advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
  if (chain.isEmpty()) {
    // 没有增强，直接反射调目标
    return AopUtils.invokeJoinpointUsingReflection(target, method, args);
  }
  MethodInvocation mi = new ReflectiveMethodInvocation(proxy, target, method, args, chain);
  return mi.proceed(); // ← 进入“洋葱式”执行
}
```

ReflectiveMethodInvocation.proceed() 是一个**索引前进**的循环/递归，不会生成新的类层级：

```
Object proceed() throws Throwable {
  if (this.currentInterceptorIndex == this.interceptors.size() - 1) {
    // 链到底了，真正调用目标方法
    return invokeJoinpoint();
  }
  Object next = this.interceptors.get(++this.currentInterceptorIndex);
  // 动态切点要先 matches 一下
  MethodInterceptor interceptor = unwrap(next);
  return interceptor.invoke(this); // 拦截器里通常会调用 invocation.proceed()
}
```

所以：**只有一个代理对象**，但运行时控制流像：

```
Validate.invoke → Tx.invoke → Log.invoke → target.method → Log.after → Tx.commit → Validate.after
```





## **2) CGLIB 代理时长什么样**

CGLIB 生成一个**目标类的子类**，把可拦截的方法 override，主体统一转发到一个 MethodInterceptor（Spring 的 DynamicAdvisedInterceptor）：

```
// 伪代码：CGLIB 子类
class MyService$$EnhancerBySpringCGLIB extends MyService {
  private final MethodInterceptor callback; // = DynamicAdvisedInterceptor

  @Override
  public Result doWork(Arg a) {
    return (Result) callback.intercept(this, MyService.class.getMethod("doWork", Arg.class),
                                       new Object[]{a}, methodProxy);
  }
}
```

DynamicAdvisedInterceptor.intercept(...) 的内部逻辑与 JDK 版本一样：**取链 → 构造 CglibMethodInvocation（继承自 ReflectiveMethodInvocation）→ proceed() 沿链执行**。

因此 CGLIB 也只有**一个代理类**，不套娃。







## **3) “多 Advisor 一次成型”的样子**

你这段：

```
ProxyFactory pf = new ProxyFactory();
pf.setTarget(myTarget);
pf.setProxyTargetClass(true); // 或根据接口走 JDK

pf.addAdvisor(txAdvisor);
pf.addAdvisor(loggingAdvisor);
pf.addAdvisor(validateAdvisor);
MyService proxy = (MyService) pf.getProxy();
```

- ProxyFactory 里把这三条 Advisor **一次性**装进 AdvisedSupport。
- 生成 **一个** 代理（JDK 或 CGLIB）。
- 每次调用目标方法，都会按**确定的顺序**拉起对应的 MethodInterceptor 列表并执行。**没有**“代理再包代理”的第二次包装。

> 视觉上像“外层校验 → 里层事务 → 最里层日志 → 目标方法”，但这并不是多层类，而是**同一个代理**在一次调用里按顺序把三个拦截器串起来。





## **4) 顺序是谁在外、谁在内？**

- 顺序由 @Order / Ordered / 注册顺序 等综合决定（Spring 用 AnnotationAwareOrderComparator 排序）。

- 事务、校验、日志**默认**顺序不一定符合你的直觉；生产里建议**显式设置顺序**：

  - @EnableTransactionManagement(order = …) / 给事务 Advisor 配 order；
  - MethodValidationPostProcessor#setOrder(...)（方法级 Bean 校验）；
  - 自定义切面用 @Order(n)（数值越小，**越靠外**）。

  





## **5) 小小“单步跟踪”示例（感受洋葱流）**

假设排序结果是：**Validate → Tx → Log**：

```
proxy.doWork()
 └─ JdkDynamicAopProxy.invoke()
     └─ chain = [MethodValidationInterceptor, TransactionInterceptor, LoggingInterceptor]
     └─ proceed():
         1) MethodValidationInterceptor.invoke(mi)
            - 校验参数
            - return mi.proceed()
              2) TransactionInterceptor.invoke(mi)
                 - beginTx
                 - try { return mi.proceed(); }
                       3) LoggingInterceptor.invoke(mi)
                          - log before
                          - result = mi.proceed()
                                4) invokeJoinpoint() → target.doWork()
                          - log after
                          - return result
                   - commitTx / rollback
```

看到了吗：**像层层嵌套**，但源码里只是**一次链式推进**，没有多层代理类。





## **6) 顺带提醒的两个边界**

- **自调用**：目标对象内部直接 this.xxx()，不会走代理，也就不会进链；需要从代理外部调用或拆分到另一个 bean。
- **final/private 方法**：JDK 代理只拦接口方法；CGLIB 也无法拦截 final 方法（private 也不行）。





### **一句话**

Spring AOP 的“多 Advisor 一次成型”是：**一个代理对象 + 一条按序的拦截器链**。所谓“外层/里层”的观感来自**运行时的 proceed 调用栈**，不是“生成了很多层套娃代理”。