“标量替换”（Scalar Replacement，常缩写为 SR）是 HotSpot JIT（主要是 C2 编译器）基于**逃逸分析（Escape Analysis, EA）的一种优化：**

**当 JIT 证明某个新建对象不会逃出当前方法/线程可见范围**、也不需要“对象身份”（identity）时，就**不真正分配这个对象**，而是把它的各个字段“拆开”成若干个**标量局部变量/寄存器**来保存与传递。这样既省掉了堆分配与 GC 压力，也减少了字段读写的间接寻址开销。



# **它具体做了什么**

- **对象分解**：把聚合对象（aggregate）拆成多个标量（int/long/reference …）。
- **消除分配**：如果该对象被判定为 *NoEscape*（或足够受限的 *ArgEscape*），对应的 new 会被移除。必要时这些标量会放在栈帧或寄存器里。
- **连带优化**：
  - 字段读写常被内联成对标量的直接读写；
  - 有时可配合 **锁消除**（EliminateLocks）去掉无必要的 synchronized 开销；
  - 结合循环内联/代码移动，减少内存流量。





# **触发前提（与逃逸分析的关系）**

JIT 会构建“连接图”（connection graph）判断对象是否逃逸：

- **NoEscape**：不逃出当前方法；最容易进行标量替换与分配消除。
- **ArgEscape**：仅作为参数传入已知且可分析的调用点，仍可能优化。
- **GlobalEscape**：被返回、存入全局/数组/逃逸到未知方法等 → 不能标量替换。



常见**阻碍**标量替换的行为：

- 把对象**返回**、赋到**外部可见**的字段/数组元素、交给**未知或未内联**的方法；
- 需要“对象身份”的操作：例如 System.identityHashCode(obj)、对同一对象做 synchronized(obj)（若不能被证明冗余）、把对象放到需要稳定身份的结构中等；
- 反射/Unsafe/VarHandle 等导致别名关系不可分析的场景；
- 写入/读取 **volatile** 相关路径可能限制优化。







# **好处**

- **减少堆分配**和 **GC 压力**（TLAB/eden 使用下降）；
- **提升局部性与寄存器利用**：字段读写变成对局部标量的访问；
- **降低锁开销**（若可与锁消除配合）。





# **示例（概念演示）**

```
class Point { int x, y; }

int sum() {
    Point p = new Point(); // 可能被消除
    p.x = 1;
    p.y = 2;
    return p.x + p.y;      // -> 直接用两个局部标量 1 和 2 计算
}
```

在 SR 生效时，new Point() 不会真正发生，x/y 成为两个标量，返回值直接是常量折叠后的 3。





# **与“栈上分配”的区别**

常听到“逃逸分析让对象栈上分配”。更精确地说：

- **HotSpot 的主路径是“分配消除 + 标量替换”**：压根不分配对象；若标量溢出再落到栈槽。
- 你可以把它理解为“更强的栈上分配”，但本质是**把对象打散**而非把完整对象结构搬到栈上。





# **如何观察/验证**

> 注意：微基准很容易被 JIT 优化“骗掉”，建议用 JMH。

- 开关（默认基本开启）：

  - -XX:+DoEscapeAnalysis（默认开）
  - -XX:+EliminateAllocations（默认开）
  - -XX:+EliminateLocks（配合锁消除，默认开）

  

- 诊断日志（示例，JDK 8）：

  - -XX:+UnlockDiagnosticVMOptions -XX:+PrintEscapeAnalysis -XX:+PrintEliminateAllocations

    日志里会出现诸如 *“allocation eliminated”*, *“scalar replaced”* 的字样。

  

- JDK 9+ 使用统一日志，可用 -Xlog 查询 eliminate/escape 相关标签（不同版本标签名略有差异）。







# **什么时候“看起来该生效却没生效”？**

- 你的对象**被当作参数**传给了**未内联**或**多态过深**的方法；
- **数组/集合持有**这个对象导致很可能 GlobalEscape；
- 代码里**读取 identity**（identityHashCode）、**在对象上加锁**且无法证明冗余；
- **反射/Unsafe**/JNI 等破坏了可分析性；
- **寄存器压力太大**或代码形状不利，JIT 出于权衡放弃了 SR。





# **小结**

> **定义**：标量替换 = “将不逃逸、无身份需求的对象拆成若干标量，进而消除对象分配”的 JIT 优化。

> **核心依赖**：逃逸分析。

> **收益**：少分配、少 GC、少间接访问、可联动锁消除。

> **非保证**：是否生效取决于可分析性、内联、代码形状与寄存器压力等多因素。

