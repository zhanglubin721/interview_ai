# **这四个屏障到底各拦什么？**

把内存操作分成 **Load(读)** / **Store(写)**。屏障命名是“左边→右边”的**不许越界**规则。

- **LoadLoad**：禁止把**屏障前的读**与**屏障后的读**重排。

  用途：先读到一个“就绪位/标志”（读1），再读数据（读2）时，确保读2不会被提前到读1之前。

- **LoadStore**：禁止把**屏障前的读**与**屏障后的写**重排。

  用途：先读状态，再进行写入；防止这次写被提前到状态读取之前。

- **StoreStore**：禁止把**屏障前的写**与**屏障后的写**重排。

  用途：先写数据，再“发布”一个标志；确保“发布写”绝不会跑到数据写之前——常见的**release**一半。

- **StoreLoad**：禁止把**屏障前的写**与**屏障后的读**重排（最强、最贵）。

  用途：完整**全栅栏**（full fence）能力，确保前面的所有写在后续任何读之前“被看见”。很多体系结构上，只有它需要显式强指令。

> 记忆口诀：

- > 读在左、读在右 ⇒ **LoadLoad**

- > 读在左、写在右 ⇒ **LoadStore**

- > 写在左、写在右 ⇒ **StoreStore**

- > 写在左、读在右 ⇒ **StoreLoad**（最强）



# **JMM/HotSpot 常见拼装法（直觉版）**

> 下述是“逻辑屏障”分类；HotSpot 会根据目标 CPU 选择**最小**指令序列去兑现这些语义。

- **volatile 读（acquire）**：在**读之后**施加 LoadLoad + LoadStore

  含义：这次读到的“发布点”确定之后，**后续**的读/写都不能被拉到它之前。

- **volatile 写（release）**：在**写之前**施加 StoreStore（有的实现还会在**写之后**加 StoreLoad 来收紧顺序）

  含义：这次写之前的普通读/写都不能越过它跑到后面；写完后的读也不能穿回去（若加了 StoreLoad）。

- **解锁（unlock, 释放锁）**：表现为 **release**，至少有 StoreStore 语义；

  **加锁（lock, 获得锁）**：表现为 **acquire**，至少有 LoadLoad + LoadStore 语义。

  （实际锁路径里还伴随互斥指令/原子指令，常等价于全栅栏。）

- **CAS/原子增（compareAndSet / xadd）**：通常等价于一次**读-改-写的原子指令**，并自带**全栅栏效果**（或 acquire/release/seqcst 变体），在 x86 上是带 lock 前缀的指令；在 ARM 上是 ldxr/stxr 自旋 + dmb 或 ldar/stlr 变体。

> 将这几条和 happens-before 串起来：

- > **release** 让“之前的写”**先**对外可见；

- > **acquire** 让“之后的读/写”**后**再进行；

- > 二者一搭桥 + 传递性 ⇒ 可见性链成立。



# **为什么“StoreLoad”最贵、何时需要？**

- 它禁止 **写→读** 的越界，是**唯一**能挡住这种乱序的通用屏障（很多 CPU 的弱序只在这里需要强制发指令）。
- 用途：实现**全局顺序更强**的场景（例如严格的顺序一致性栅栏、某些解锁/唤醒路径、极端发布/可见性收束）。
- 在普通 **volatile** 语义下，很多架构并不需要对每次 volatile 写都显式发 StoreLoad（见下节平台映射）。



# **平台映射（直观对照）**

- **x86-64（TSO）**：天然保证 LoadLoad / LoadStore / StoreStore，只有 **StoreLoad** 可能乱序。

  - **volatile 读/写**：通常就是普通 mov（编译器不重排即可达语义）；
  - **需要全栅栏**时：mfence 或任何 lock 原子指令（如 lock add, lock cmpxchg）能当作 StoreLoad；
  - **CAS/Atomic**：lock cmpxchg/xadd 自带全栅栏效果。

  

- **ARMv8/AArch64（弱序）**：提供带语义的指令：

  - **volatile 读（acquire）**：LDAR

  - **volatile 写（release）**：STLR

  - **全栅栏/域**：DMB ish / DSB 等

    （因此在 ARM 上，JIT 通常不需要显式拼四种逻辑屏障，而是直接发 A/R 变体指令。）



# **放到代码场景里看一眼**

**发布-获取（volatile 标志）**

```
// writer
data = 42;           // 普通写
ready = true;        // volatile 写（前置 StoreStore，发布点）
// reader
if (ready) {         // volatile 读（后置 LoadLoad+LoadStore，获取点）
    use(data);       // 看到 42
}
```

**DCL（双重检查 + volatile）**

```
if (inst == null) {                    // volatile 读（acquire）
  synchronized(...) {
    if (inst == null) {
      inst = new Obj();                // volatile 写（release, 防止构造重排到发布之后）
    }
  }
}
```

**为什么 x++ 用 volatile 仍不原子**

x++ = 读 → 算 → 写，volatile 只能用上面的“拦重排/保可见”，**不能把三步粘成一条原子指令**；要用 AtomicLong.incrementAndGet()（x86: lock xadd；ARM: ldxr/stxr）。

# **常见误区快速纠正**

- **“volatile 就是每次直达主存”**：这是比喻。真正做事的是“编译器不重排 + 必要的 CPU 屏障 + 硬件一致性”。
- **“release 只要 StoreStore？”**：语义上是“不能把**之前的内存操作**移到它之后”，实践里通常靠 StoreStore（挡写）+ 编译器顺序（挡读）；不同 JVM/架构可能在写后再加更强的收束（如 StoreLoad）以满足更强保证或实现细节。
- **“四类屏障就是四条指令”**：不一定。它们是**语义类别**；具体是否需要、发哪条指令，取决于**JVM + 目标 CPU**。





**一页速记**

- LoadLoad：读后读不越界；
- LoadStore：读后写不越界；
- StoreStore：写后写不越界（发布数据→发布标志）；
- StoreLoad：写后读不越界（全栅栏，最强）。
- volatile：读后（LL+LS），写前（SS）（实现上因平台而异）；锁= acquire/release；CAS≈全栅栏。