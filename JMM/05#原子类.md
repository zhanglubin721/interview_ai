# **1) 它们解决什么问题？**

- **单变量的原子读-改-写（RMW）**：在不加锁的前提下，保证“读取旧值 → 基于旧值计算新值 → 写回”是一个**线性化的原子动作**（线性化点通常在 CAS 成功的那一刻）。
- **内存可见性/有序性**：原子类的方法自带 **volatile 级别** 的发布/获取（acquire/release）语义，建立 happens-before。

> 不能解决：**跨多个变量的原子性/不变式**（需要锁/事务），也不会自动避免所有 **ABA**（需要带版本/标记的原子引用）。





# **2) 内存语义（JMM 视角，简明版）**

- get()：**volatile 读（acquire）**
- set(v)：**volatile 写（release）**
- lazySet(v)：**release**（弱于 volatile 写，允许稍后对外可见）
- compareAndSet(e,u)（成功）：≈ **一次 volatile 读 + 一次 volatile 写**（建立 hb）
- weakCompareAndSet…：可能**偶发失败**（spurious failure），要**循环**重试；JDK 9+ 通过 VarHandle 暴露 Plain/Acquire/Release/Volatile 多种序。

底层映射：

- x86：lock cmpxchg/xadd（通常具备很强的栅栏效果）
- ARMv8：ldxr/ldaxr + stxr/stlxr（LL/SC）+ acq/rel 语义







# **3) 家族成员 & 典型用法**

## **3.1 标量原子类**

- AtomicBoolean / AtomicInteger / AtomicLong / AtomicReference<T>
  - **模式**：CAS 循环（失败重试）
  - **常用 API**：

```java
// 计数/发号器
AtomicLong seq = new AtomicLong();
long id = seq.incrementAndGet();     // 线性化点 = CAS 成功处

// 条件更新
AtomicReference<State> st = new AtomicReference<>(INIT);
st.compareAndSet(INIT, RUNNING);

// 函数式更新（函数需无副作用，可能被多次调用）
a.updateAndGet(x -> x * 2 + 1);
```

- **getAndXxx vs xxxAndGet**：前者返回旧值，后者返回新值，线性化点相同。







## **3.2 原子数组**

- AtomicIntegerArray / AtomicLongArray / AtomicReferenceArray<T>

  - **每个索引位置**都是独立的 CAS 单元；get(i)/set(i)/compareAndSet(i,…) 具备 per-slot 的 volatile 语义。
  - **构造器**接收现有数组时会**复制一份内部数组**（避免外部别名破坏原子语义）。
  - 适用于“**定长槽位** + 高并发独立更新”，比如分桶计数。

  





## **3.3 字段更新器（反射 + CAS）**

- AtomicIntegerFieldUpdater / AtomicLongFieldUpdater / AtomicReferenceFieldUpdater
  - 对 **某个类的“指定 volatile 实例字段”** 做原子更新（节省每对象 1 个原子类包装的内存）。
  - **要求**：字段必须 volatile、**非 final**、**实例字段**（非 static），可见性需允许访问。
  - **注意**：反射 + 访问校验，**慢**于直用 AtomicLong；仅在**大量对象、强内存约束**时考虑。





## **3.4 防 ABA 的原子引用**

- AtomicStampedReference<T>：引用 + **版本号（int stamp）**，CAS 同时比较（ref, stamp）
- AtomicMarkableReference<T>：引用 + **布尔标记**（逻辑删除）

```java
AtomicStampedReference<Node> head = new AtomicStampedReference<>(null, 0);
void push(Node x) {
    int[] s = new int[1];
    Node h;
    do { h = head.get(s); x.next = h; }
    while (!head.compareAndSet(h, x, s[0], s[0] + 1));
}
```





## **3.5 高吞吐加法器/累加器**

- LongAdder / DoubleAdder（**分段累加**，汇总 sum() 非线性化）

  - 低争用：CAS base
  - 高争用：懒初始化 cells[]（长度为 2 的幂），**按线程探针散列到不同 Cell** 做 CAS，冲突多则 **rehash/扩容**，并用 @Contended 缓解**伪共享**
  - 适合**统计/监控**（QPS、计数）；不适合“每次读取都要精准一致”的业务扣减

  

```java
LongAdder adder = new LongAdder();
adder.increment();
long s = adder.sum();      // 近似快照
```

- LongAccumulator / DoubleAccumulator：自定义二元运算累加（如 max/min/sum）



这里的“**线程探针（probe）**”指的是**每个线程私有的、可变的伪随机整数**，放在 Thread 对象里（比如 threadLocalRandomProbe 字段）。LongAdder（准确说是它的基类 Striped64）用它来把线程**均匀地散列**到 cells[] 的某个槽位上，并在发生碰撞时**快速换槽**。

### **线程探针是什么**

- 一个**每线程**维护的 **int** 值，初始为非零伪随机数。
- 由 ThreadLocalRandom 维护/初始化（getProbe() 取值；advanceProbe() 在碰撞时扰动）。
- 存放在 Thread 里，不走 ThreadLocal 哈希表，**读取/更新成本极低**。



### **线程探针怎么用在** **LongAdder**

假设 cells.length = 2^k，索引计算与换槽逻辑大致是：

**以下内容简直就是 HashMap 的翻版**

```java
int probe = getProbe();                     // 每线程的探针值
int m = cells.length - 1;                   // 掩码（2^k - 1）
int i = probe & m;                          // 命中槽位

Cell c = cells[i];
if (c == null) {
    // 竞争初始化/放置新的 Cell
} else if (!c.cas(v, v + x)) {              // 该槽位 CAS 冲突
    probe = advanceProbe(probe);            // 扰动 probe（xorshift）
    // 再用新的 probe & m 命中另一个槽位，或触发扩容
}
```

- **为什么 & (2^k - 1)？** 数组长度取 2 的幂，位与即可代替取模，**快**。
- **为什么发生冲突要 advanceProbe？** 说明当前槽位“拥挤”，把本线程的探针做一次 **xorshift** 扰动，可均匀跳到**别的槽**，避免大家一直撞同一格。

> 你可以把 probe 想成“每个线程持有的一把**可变钥匙**”，钥匙决定它进哪扇门；门太挤就**抖一抖钥匙**再试另一扇门。



### **为什么不用线程 ID /** **hashCode()**？

- **线程 ID 不可变**：一旦与某个 2^k 长度的表结构发生“糟糕对齐”，**永远**命中同几格，冲突无法缓解。
- **不可快速扰动**：发生碰撞时最好能**瞬时换槽**；probe 是可变的，advanceProbe 就为此设计。
- **分布性与成本**：probe 用轻量的 **xorshift** 生成序列，分布均匀、计算便宜；而 identityHashCode/ThreadLocal 读取都更重。



### **它与扩容的配合**

- 若多次换槽仍冲突，并且 cells.length < CPU 核数，LongAdder 会在短暂拿到 cellsBusy 后**把 cells 扩成 2 倍**。
- 扩容后同一组 probe 通过 & (2^(k+1)-1) 自然会散得更开，**冲突率下降**。



### **小结（记住这 3 句）**

1. **线程探针 = 每线程可变的伪随机种子**，存在线程对象里，读取/更新很快。
2. index = probe & (cells.length-1) 把线程分散到不同 Cell；**冲突就 advanceProbe**，换槽再试。
3. 这样能把“一个逻辑计数”拆到**多个物理地址**并行 CAS，**降低热点和缓存线乒乓**，是 LongAdder 吞吐高的关键之一。



### LongAdder.sum()

**LongAdder.sum() 就是把 base 和每个 Cell.value 逐个读一遍然后相加**。因为这整个过程**不加锁、不做全局栅栏**，读到的是不同时间点的片段，所以结果是**非线性化（近似快照）**。

```java
long s = base;                 // 先读 base（volatile 读）
Cell[] cs = cells;
if (cs != null) {
  for (Cell c : cs) {
    if (c != null) s += c.value;   // 逐个读 Cell.value（volatile 读）
  }
}
return s;
```





## **3.6 JDK 9+ 的** **VarHandle**（重点）

- 不是“类”，是**更底层的内存访问句柄**，提供 getAcquire/setRelease/compareAndExchangeAcquire/… 等**细粒度内存序** API。原子类内部已逐步改用它实现。
- 适合对**性能/内存序**有特定要求的底层组件。



- **JDK 9+（VarHandle 路径）**：incrementAndGet() 委托给 getAndAdd(1)；JIT 通常把它内联为硬件原子加（如 x86 的 lock xadd）。只有在这条原子指令**成功把旧值加 1 并写回**后，方法才返回（再 +1 变成新值返回）。
- **JDK 8/某些平台**：落到 Unsafe.getAndAddLong 的 **CAS 循环**：

```java
long v;
do {
    v = getLongVolatile(...);          // 读旧值
} while (!compareAndSwapLong(..., v, v+1)); // 失败就重试
return v+1;
```

- 只有 CAS **成功写回**了，才返回。

两条路共同点：**这次更新必须成功提交**，否则不会返回。



# **4) 常见坑 & 设计要点**

1. **volatile ≠ 原子 RMW**

   volatile int x; x++; 仍是“读→算→写”三步，**会丢更新**。要原子自增：AtomicLong.incrementAndGet()、LongAdder.increment() 或加锁。

2. **ABA 问题**

   只比较“当前值==期望值”的 CAS 可能被 **A→B→A** 欺骗。

   - 对计数/指标类无害；
   - 对无锁栈/链表等致命 → 用 AtomicStampedReference 或把**版本/标志**并入状态一并 CAS。

   

3. **函数式更新需“无副作用”**

   updateAndGet / accumulateAndGet 里的函数可能被**多次调用**（CAS 失败重试），不得产生副作用。

4. **高争用下 CAS 退化**

   CAS 失败-自旋 + 缓存线乒乓 → 抖动明显。

   - 计数类用 **LongAdder**；
   - 其它场景考虑 **退避（backoff）**、**消除（elimination）** 或直接**加锁合批**。

   

5. **原子数组与可见性**

   仅对**该索引**的操作有 volatile 语义；不同索引之间没有额外顺序。

6. **字段更新器的限制**

   只能操作 **实例 volatile 字段**，非 static；访问检查严格；性能不如直接原子类。

7. **跨变量不变式仍需锁**

   原子类**只保证单位置**的原子性；若更新涉及多处（例如转账两端扣加），用锁或更高层协议。







# **5) 选型速查**

| **诉求**                                 | **推荐**                                           |
| ---------------------------------------- | -------------------------------------------------- |
| 精确的单变量 RMW（发号、计数、状态机位） | AtomicLong/Integer/Reference                       |
| 高并发计数/指标，读为近似                | LongAdder / LongAccumulator                        |
| 无锁结构且需防 ABA                       | AtomicStampedReference / MarkableReference         |
| 大量对象节省包装开销                     | Atomic*FieldUpdater（字段必须 volatile，实例字段） |
| 需要精细控制内存序                       | VarHandle（Acquire/Release/Volatile/Plain 变体）   |
| 复杂跨变量原子性/条件等待                | synchronized / ReentrantLock（更强语义）           |







# **6) 两段常用范式（可直接套）**

**（A）安全原子自增（精确值）**

```
AtomicLong c = new AtomicLong();
long v = c.incrementAndGet();    // 线性化
```

**（B）并发计数（高吞吐）**

```java
LongAdder adder = new LongAdder();
void onEvent() { adder.increment(); }
long qps() { return adder.sum(); }  // 近似快照
```

**（C）无锁栈骨架（注意 ABA）**

```java
class Node { Node next; int v; }
AtomicReference<Node> head = new AtomicReference<>();

void push(Node x) {
  Node h;
  do { h = head.get(); x.next = h; } while (!head.compareAndSet(h, x));
}
```

> 要严格避免 ABA：换 AtomicStampedReference<Node>。







# **7) 一页记忆点**

- 原子类 = **CAS + volatile 语义** 的工程化封装；CAS 成功处是**线性化点**
- lazySet（release）、weakCAS（可能偶发失败 → 循环）
- LongAdder = **分段 CAS** + rehash/扩容 + @Contended，sum() 非线性化
- **ABA**：数值统计无害；无锁结构致命 → Stamped/Markable
- **只管单位置**；跨位置 invariants 用锁