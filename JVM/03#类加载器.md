# **一、生命周期四阶段（JVM 规范视角）**

以一个二进制名为 com.foo.Bar 的类为例：

1. **Loading（加载）**

- 定位 .class 字节流（classpath、module path、网络、自定义来源等），读入字节。
- 选择一个 ClassLoader 负责它，并创建 java.lang.Class 对象与之关联。
- **类的身份 = (ClassLoader 实例, 二进制名)**，二者任意不同就被 JVM 当成**不同类型**。



2. **Linking（链接）**：含三步

- **Verification（验证）**：字节码合法性、类型安全、栈映射帧校验等。
- **Preparation（准备）**：为**类变量（static）分配存储并置默认值**；对带 ConstantValue 的 static final（原始类型/String）会在此直接赋常量值。
- **Resolution（解析）**：把常量池里的符号引用（类/字段/方法）**按需**解析为直接引用（懒解析，可能在首次用到时才做）。



3. **Initialization（初始化）**

- 执行类的 <clinit>：由**静态字段的非编译期常量初始化** + **静态代码块**合成。
- 初始化是**同步**的：同一时刻仅一个线程在跑 <clinit>，其余线程阻塞等待。
- 触发时机（JLS 12.4.1 填几条你面试必备）：new、getstatic/putstatic（若目标非常量）、invokestatic、反射、Class.forName、子类初始化会先触发父类初始化。**使用“编译期常量”不会触发**（因为已被编译器内联）。

> 以上四步里，**Loading/Linking/Initialization**通常在一次 loadClass(..., resolve=true) 的过程中按需发生。





# **二、委派模型（Parent Delegation）**

HotSpot 默认三层（逻辑概念）：

- **Bootstrap（引导）**：用原生代码实现，加载 JDK 核心类（Java 9+ 来自模块 java.base 等）。
- **Platform（平台，JDK9 以前叫 Extension）**：负责“非基础但平台级”的库。
- **Application（系统类加载器）**：加载 classpath/应用模块里的类。
- **自定义 ClassLoader**：由你/框架实现，常见于容器、插件、字节码增强等。

**父优先**是默认策略：

> AppLoader.loadClass(“X”) → 先看**父**是否能加载（一路上推到 Bootstrap）；父都不行，**自己**再尝试。

好处：**安全+一致性**（核心类不被应用重写）。缺点：某些插件/容器需要“**child-first**”（如 Tomcat WebAppClassLoader、OSGi/JPMS 的隔离模型），这时会改写默认流程。





# **三、**loadClass**的标准算法（很面试）**

HotSpot java.lang.ClassLoader#loadClass(String, boolean) 典型逻辑：

1. findLoadedClass(name)：**本加载器**是否已加载过？是→直接返回。
2. parent.loadClass(name, false)：**委派给父**；若无父则交给 Bootstrap。
3. 若父失败：调用 **findClass(name)**（你在自定义加载器里实现，去找 bytes）。
   - 找到字节：defineClass(name, bytes, ...) → JVM 验证/准备；必要时 resolveClass。
   - 找不到：抛 ClassNotFoundException。
4. resolve==true 时会触发解析链接（可能部分在首次使用时完成）。

> 资源加载（getResource*）通常也走**父优先**，但可重写。





# **四、模块/命名空间与隔离**

- **类型身份** = (loader, name)：同字节码由**两个不同 ClassLoader**加载，会被认为是**两个不同类**，互相 instanceof 为 false，甚至 ClassCastException。
- **重复定义**：同一个加载器第二次 defineClass 同名会报 LinkageError: duplicate class definition。
- **JPMS（Java 9+ 模块系统）**：增加了“导出/读取”规则；Bootstrap/Platform/App 也是模块感知的。
- **包封印（Sealing）**：JAR 可声明包只允许来自同一源，冲突时报 SecurityException。





# **五、上下文类加载器（Context ClassLoader）**

- 许多**框架/容器**里，库代码运行在“父加载器上下文”中，却需要**加载应用层类**（只在子加载器可见）。
- 解决：通过 Thread.currentThread().getContextClassLoader() **反转**父优先，去应用层命名空间找类/资源（典型：JNDI、JDBC SPI、ServiceLoader 等）。
- 开发/排障要点：跨线程时记得**保存与恢复**上下文类加载器，避免 ClassNotFoundException/ServiceConfigurationError。





# **六、常见问题与定位**

- **ClassNotFoundException** **vs** **NoClassDefFoundError**

  - 前者：加载阶段就找不到（classpath 配置或加载器策略问题）。
  - 后者：**运行时用到才解析失败**（缺依赖/版本冲突/初始化异常后再次使用）。

  

- **IncompatibleClassChangeError** **/** **NoSuchMethodError** **/** **NoSuchFieldError**

  - 二进制不兼容或类被**不同 ClassLoader**加载导致签名不匹配。

  

- **ClassCastException** **明明类型一样却不能转**

  - 打印 obj.getClass().getClassLoader() 你会发现**来自两个加载器**。

  

- **初始化死锁**

  - 两个类在 <clinit> 里互相触发对方初始化，JVM 对 <clinit> 的同步会形成死锁；JFR/线程栈可见。



# **七、与 GC/内存的关系（Metaspace）**

- 类元数据存于 **Metaspace**（JDK8+，本地内存），释放条件：**定义它的 ClassLoader 不可达**（以及它定义的所有类都不可达）。
- 容器/热部署场景常见 **ClassLoader 泄漏**（ThreadLocal、静态集合、JNI 句柄、Timer 未停止等）导致 **Metaspace OOM**。
- 诊断：jcmd VM.native_memory summary / -XX:MaxMetaspaceSize / Heap dump 看 ClassLoader 引用链。



# **八、自定义加载器最小骨架（记这个就能写）**

```
public class MyLoader extends ClassLoader {
    public MyLoader(ClassLoader parent) { super(parent); }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] bytes = fetchBytesSomehow(name); // 你来实现：文件/网络/生成
        if (bytes == null) throw new ClassNotFoundException(name);
        // definePackage 可选：包元数据/封印
        return defineClass(name, bytes, 0, bytes.length);
    }
}
```

> 若想**child-first**：在 loadClass 里先 findLoadedClass，再**先尝试 findClass**，最后才委派给父（注意要妥善放行 JDK/敏感包给父加载器）。





# **九、JIT/生成类与新特性**

- 动态代理、CGLIB、ByteBuddy 会在运行时**生成字节码**并通过 defineClass（或 MethodHandles.Lookup#defineClass、JDK15+ 的 **Hidden Classes**）定义。
- **CDS/AppCDS**（Class Data Sharing）：预处理核心类元数据到共享档，加快冷启动的**验证/解析**与映射。
- **多版本 JAR（Multi-Release JAR）**：加载器会按运行时版本挑选合适版本的类。





# **十、工作流程一图流（ASCII）**

```
call site → ClassLoader.loadClass(name, resolve?)
   ├─ findLoadedClass(name)? ── yes → return
   ├─ parent.loadClass(name)? ── yes → return
   └─ findClass(name)
        └─ bytes → defineClass(name, bytes)
              ├─ Verification
              ├─ Preparation (static 默认值 / ConstantValue 赋值)
              ├─ (lazy) Resolution
              └─ (若 resolve) resolveClass()
                     ↓
             初始化触发点 → <clinit> (一次且同步)
```





## **小结（面试 20 秒版）**

- 类加载流程：**加载 → 验证 → 准备 →（惰性）解析 → 初始化**；初始化触发点是 new/getstatic/invokestatic/反射 等。
- **委派模型**：默认**父优先**，保证核心类一致性；容器/插件可能用**子优先**或多命名空间。
- **类型身份 = (ClassLoader, name)**，不同加载器加载同名类就是**不同类型**；大量线上“同名不可转型/方法缺失”源于此。
- 排障：看 **ClassLoader 层次、上下文类加载器**、依赖版本边界；Metaspace 问题多半是 ClassLoader 泄漏。